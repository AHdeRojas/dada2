% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/paired.R
\name{mergePairs}
\alias{mergePairs}
\title{Merge paired forward and reverse reads after DADA denoising.}
\usage{
mergePairs(dadaF, derepF, dadaR, derepR, minOverlap = 20, maxMismatch = 0,
  returnRejects = FALSE, propagateCol = character(0),
  justConcatenate = FALSE, verbose = FALSE)
}
\arguments{
\item{dadaF}{(Required). A \code{\link{dada-class}} object.
 The output of dada() function on the forward reads.}

\item{derepF}{(Required). A \code{\link{derep-class}} object.
 The derep-class object returned by derepFastq() that was used as the input to the
 dada-class object passed to the dadaF argument.

 Alternatively the map itself (derepFastq()$map) can be provided in place of the
 derep-class object.}

\item{dadaR}{(Required). A \code{\link{dada-class}} object.
 The output of dada() function on the reverse reads.}

\item{derepR}{(Required). A \code{\link{derep-class}} object.
 See derepF description, but for the reverse reads.}

\item{minOverlap}{(Optional). A \code{numeric(1)} of the minimum length of the overlap (in nucleotides)
 required for merging the forward and reverse reads. Default is 20.}

\item{maxMismatch}{(Optional). A \code{numeric(1)} of the maximum mismatches allowed in the overlap region.
 Default is 0 (i.e. only exact matches in the overlap region are accepted).}

\item{returnRejects}{(Optional). A \code{logical(1)}. Default is False.
 If true, the pairs that that were rejected based on mismatches in the overlap
 region are retained in the return data.frame.}

\item{propagateCol}{(Optional). \code{character}. Default is \code{character(0)}.
 The mergePairs return data.frame will include copies of columns with names specified
 in the dada-class$clustering data.frame.}

\item{justConcatenate}{(Optional). \code{logical(1)}, Default FALSE.
 If TRUE, the forward and reverse-complemented reverse read are concatenated rather than merged,
   with a NNNNNNNNNN (10 Ns) spacer inserted between them.}

\item{verbose}{(Optional). \code{logical(1)} indicating verbose text output. Default FALSE.}
}
\value{
Dataframe. One row for each unique pairing of forward/reverse denoised sequences.
\itemize{
 \item{$abundance: }{Number of reads corresponding to this forward/reverse combination.}
 \item{$sequence: The merged sequence.}
 \item{$forward: The index of the forward denoised sequence.}
 \item{$reverse: The index of the reverse denoised sequence.}
 \item{$nmatch: Number of matching nts in the overlap region.}
 \item{$nmismatch: Number of mismatching nts in the overlap region.}
 \item{$nindel: Number of indels in the overlap region.}
 \item{$prefer: The sequence used for the overlap region. 1=forward; 2=reverse.}
 \item{$accept: TRUE if overlap between forward and reverse denoised sequences was at least minOverlap and had at most maxMismatch differences.
         FALSE otherwise.}
 \item{$...: Additional columns specified in the propagateCol argument.}
}
}
\description{
This function attempts each denoised pair of forward and reverse reads, rejecting any
which do not sufficiently overlap or which contain too many (>0 by default) mismatches in the
overlap region. Note: This function assumes that the fastq files for the
forward and reverse reads were in the same order. Use of the concatenate option will
result in concatenating forward and reverse reads without attempting a merge/alignment step.
}
\examples{
derepF = derepFastq(system.file("extdata", "sam1F.fastq.gz", package="dada2"))
derepR = derepFastq(system.file("extdata", "sam1R.fastq.gz", package="dada2"))
dadaF <- dada(derepF, err=tperr1, errorEstimationFunction=loessErrfun, selfConsist=TRUE)
dadaR <- dada(derepR, err=tperr1, errorEstimationFunction=loessErrfun, selfConsist=TRUE)
mergePairs(dadaF, derepF, dadaR, derepR)
mergePairs(dadaF, derepF, dadaR, derepR, returnRejects=TRUE, propagateCol=c("birth_ham", "birth_fold"))
mergePairs(dadaF, derepF, dadaR, derepR, justConcatenate=TRUE)
}
\seealso{
\code{\link{derepFastq}}, \code{\link{dada}}
}

