% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dada.R
\name{dada}
\alias{dada}
\title{dada infers the sample sequence in amplicon data.}
\usage{
dada(uniques, quals = NULL, err, err_function = NULL,
  self_consist = FALSE, ...)
}
\arguments{
\item{uniques}{(Required). Named integer vector or list of named integer vectors.
 Each uniques vector is an integer vector of abundances, named by the unique DNA
   sequence to which that abundance corresponds.
 Sequences are only allowed to contain A/C/G/T characters.
 A list of such vectors can be provided, in which case the error model will be
   shared across these samples when denoising.}

\item{quals}{(Optional). Numeric matrix containing average quality scores for each unique at each position.
 The quals matrix has a row for each corresponding unique in the uniques vector, and a column for each
 sequence position. So nrow(quals) == length(uniques) and ncol(quals) == nchar(uniques[[foo]]).}

\item{err}{(Required). 16xN numeric matrix.
 The matrix of estimated rates for each possible nucleotide transition (from sample nucleotide to read nucleotide).
 Rows correspond to the 16 possible transitions (t_ij) indexed as so...
   1:A->A,  2:A->C,  3:A->G,  4:A->T,  5:C->A,  6:C->C,  7:C->G,  8:C->T,
   9:G->A, 10:G->C, 11:G->G, 12:G->T, 13:T->A, 14:T->C, 15:T->G, 16:T->T

 If USE_QUALS = TRUE, the columns correspond to a linear interpolation of quality score from QMIN and QMAX, eg. seq(QMIN, QMAX, by=QSTEP).
   err[t_ij, round((q_ave-QMIN)/QSTEP) + 1] = Prob(j in sequence | i in sample genotype and q_ave).

 If USE_QUALS = FALSE, the matrix must have only one column, which corresponds to the estimated error rate for that transition.
   err[t_ij, 1] = Prob(j in sequence | i in sample genotype).}

\item{err_function}{(Optional). Function.
  If USE_QUALS = TRUE, err_function(dada()$trans_out) is computed and taken to be the new err matrix.
   If self_consist = TRUE, the next iteration if the dada() algorithm will use this new err, and this
   will continue until the loop terminates due to convergence (or by hitting MAX_CONSIST). If
   self_consist=FALSE, err_function is only used to calculate return value $err_out, but otherwise
   has no effect on the algorithm.

  If USE_QUALS = FALSE, this argument is ignored, and transition rates are estimated by maximum likelihood (t_ij = n_ij/n_i).}

\item{self_consist}{(Optional). \code{logical(1)}
 When true, DADA will re-estimate error rates after inferring sample genotypes, and then repeat
 the algorithm using the newly estimated error rates. This continues until convergence.}

\item{...}{(Optional). All dada_opts can be passed in as arguments to the dada() function.
   eg. dada(unq, err=err_in, OMEGA_A=1e-50, MAX_CLUST=50)}
}
\value{
A multi-item List with the following named values...
\itemize{
 \item{$genotypes: }{Integer vector, named by sequence valued by abundance, of the denoised genotypes.}
 \item{$clustering: }{An informative data.frame containing information on each cluster.}
 \item{$quality: }{The average quality scores for each cluster (row) by position (col).}
 \item{$map: }{Integer vector that maps the unique (index) to the cluster/genotype (value).}
 \item{$birth_subs: }{A data.frame containing the substitutions at the birth of each new cluster.}
 \item{$trans: }{The matrix of transitions by type (row), eg. A2A, A2C..., and quality score (col)
         observed in the final output of the dada algorithm.}
 \item{$err_in: }{The err matrix used for this invocation of dada.}
 \item{$err_out: }{The err matrix estimated from the output of dada. NULL if err_function not provided.}
 \item{$opts: }{A list of the dada_opts used for this invocation of dada.}
 \item{$uniques: }{The uniques vector(s) used for this invocation of dada.}
 \item{$call: }{The function call used for this invocation of dada.}
}

 If self_consist=TRUE, $err_in is a list of length the number of times through the self_consist
   loop corresponding to the err used in each iteration. $err_out is the final estimated error rate.

 If a list of uniques vectors was provided (i.e. multiple samples) then a list of the above output lists
   is returned corresponding to each input sample.
}
\description{
The dada function takes as input the unique sequences in an amplicon sequencing sample paired
 with their abundances, and returns the sample genotypes paired with their abundances
 inferred by the Divisive Amplicon Denoising Algorithm (Rosen, Callahan, Fisher, Holmes 2012).
}

