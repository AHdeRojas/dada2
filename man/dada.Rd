% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/dada.R
\name{dada}
\alias{dada}
\title{High resolution sample inference from amplicon data.}
\usage{
dada(derep, err, errorEstimationFunction = NULL, selfConsist = FALSE, ...)
}
\arguments{
\item{derep}{(Required). A derep-class object, the output of \code{\link{derepFastq}}.

 A list of derep objects can be provided, in which case each will be independently denoised with
 a shared error model.}

\item{err}{(Required). 16xN numeric matrix. Each entry must be between 0 and 1.

 The matrix of estimated rates for each possible nucleotide transition (from sample nucleotide to read nucleotide).

 Rows correspond to the 16 possible transitions (t_ij) indexed as so...
   1:A->A,  2:A->C,  3:A->G,  4:A->T,  5:C->A,  6:C->C,  7:C->G,  8:C->T,
   9:G->A, 10:G->C, 11:G->G, 12:G->T, 13:T->A, 14:T->C, 15:T->G, 16:T->T

 Columns correspond to consensus quality scores. Typically there are 41 columns for the quality scores 0-40.
 However, if USE_QUALS=FALSE, the matrix must have only one column.}

\item{errorEstimationFunction}{(Optional). Function. Default Null.

 If USE_QUALS = TRUE, \code{errorEstimationFunction(dada()$trans_out)} is computed after sample inference finishes
   and the return value is used as the new estimate of the err matrix.

 If USE_QUALS = FALSE, this argument is ignored, and transition rates are estimated by maximum likelihood (t_ij = n_ij/n_i).}

\item{selfConsist}{(Optional). \code{logical(1)}. Default FALSE.

 If selfConsist = TRUE, the algorithm will alternate between sample inference and error rate estimation until convergence.
   Error rate estimation is performed by the errorEstimationFunction, which is required for selfConsist mode. If dada is
   run in selfConsist mode without specifying this function, the default loessErrfun will be used.

 If selfConsist=FALSE the algorithm performs one round of sample inference based on the provided err matrix.}

\item{...}{(Optional). All dada_opts can be passed in as arguments to the dada() function.

 See \code{\link{setDadaOpt}} for a discussion of the various dada options.}
}
\value{
A \code{\link{dada-class}} object or list of such objects of a list of derep objects was provided.
}
\description{
The dada function takes as input dereplicated amplicon sequencing reads and returns the inferred composition
 of the sample (or samples). Put another way, dada removes all sequencing errors to reveal the members of the
 sequenced community.
}
\details{
If dada is run in selfConsist=TRUE mode, the algorithm will infer both the sample composition and
 the parameters of its error model from the data.

dada() implements the Divisive Amplicon Denoising Algorithm as described in:

Briefly, DADA implements a statiscal test for the notion that a specific sequence was seen too many times
 to have been caused by amplicon errors from currently inferred sample sequences. Overly-abundant
 sequences are used as the seeds of new clusters of sequencing reads, and the final set of clusters
 is taken to represent the denoised composition of the sample. A more detailed explanation of the algorithm
 is found in two publications:

\itemize{
 \item{Callahan, B. J., McMurdie, P. J., Rosen, M. J., Han, A. W., Johnson, A. J., & Holmes, S. P. (2015). DADA2: High resolution sample inference from amplicon data. bioRxiv, 024034.}
 \item{Rosen, M. J., Callahan, B. J., Fisher, D. S., & Holmes, S. P. (2012). Denoising PCR-amplified metagenome data. BMC bioinformatics, 13(1), 283.}
}

DADA depends on a parametric error model of substitutions. Thus the quality of its sample inference is affected
 by the accuracy of the estimated error rates. DADA's selfConsist mode allows these error rates to be inferred
 from the data.

All of DADA's comparisons between sequences depend on pairwise alignments. This step is the most computationally
 intensive part of the algorithm, and two alignment heuristics have been implemented for speed: A kmer-distance
 screen and a banded Needleman-Wunsch alignmemt. See \code{\link{setDadaOpt}}.
}
\examples{
derep1 = derepFastq(system.file("extdata", "sam1F.fastq.gz", package="dada2"))
derep2 = derepFastq(system.file("extdata", "sam2F.fastq.gz", package="dada2"))
dada(derep1, err=tperr1)
dada(list(sam1=derep1, sam2=derep2), err=tperr1, errorEstimationFunction=loessErrfun, selfConsist=TRUE)
dada(derep1, err=inflateErr(tperr1,2), BAND_SIZE=32, OMEGA_A=1e-20)
}
\seealso{
\code{\link{derepFastq}}

 \code{\link{setDadaOpt}}
}

