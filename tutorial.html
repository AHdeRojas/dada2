<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>DADA2 Pipeline Tutorial (1.2)</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<link href="site_libs/ionicons-2.0.1/css/ionicons.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">dada2</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="dada-installation.html">Install</a>
</li>
<li>
  <a href="tutorial.html">Walkthrough</a>
</li>
<li>
  <a href="bigdata.html">Big Data</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-gear"></span>
     
    Documentation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="https://www.bioconductor.org/packages/3.4/bioc/manuals/dada2/man/dada2.pdf">Manual</a>
    </li>
    <li>
      <a href="assign.html">Taxonomy</a>
    </li>
    <li>
      <a href="species.html">Species</a>
    </li>
    <li>
      <a href="pool.html">Pooling</a>
    </li>
    <li>
      <a href="faq.html">FAQ</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-gear"></span>
     
    Evaluation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="http://dx.doi.org/10.1038/nmeth.3869">Manuscript</a>
    </li>
    <li>
      <a href="SMBS_DADA2.pdf">Symposium Slides</a>
    </li>
    <li>
      <a href="SotA.html">Benchmarking</a>
    </li>
    <li>
      <a href="https://purl.stanford.edu/mh194vj6733">Manuscript code</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://www.twitter.com/bejcal">
    <span class="ion ion-social-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/benjjneb/dada2/issues">
    <span class="fa fa-question fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/benjjneb/dada2">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">DADA2 Pipeline Tutorial (1.2)</h1>

</div>


<p>Here we walk through version 1.2 of the DADA2 pipeline on a small multi-sample dataset. Our starting point is a set of Illumina-sequenced paired-end fastq files that have been split (or “demultiplexed”) by sample and from which the barcodes/adapters have already been removed. The end product is a <strong>sequence table</strong>, a higher-resolution analogue of the ubiquitous “OTU table”, which records the number of times each ribosomal sequence variant (SV) was observed in each sample. We also assign taxonomies to the output sequences, and demonstrate how the data can be importeted into the popular <a href="https://joey711.github.io/phyloseq/">phyloseq</a> R package for the analysis of microbiome data.</p>
<hr />
<div id="starting-point" class="section level1">
<h1>Starting point</h1>
<p>This workflow assumes that the data you are starting with meets certain criteria:</p>
<ul>
<li>Non-biological nucleotides have been removed (primers/adapters/barcodes…)</li>
<li>Samples are demultiplexed (split into individual per-sample fastqs)</li>
<li>If paired reads, the forward and reverse fastqs contain reads in matching order</li>
</ul>
<p>If any of these criteria are not true for your data (are you sure primers aren’t still there?) you need to remedy those issues before beginning this workflow. See <a href="faq.html">the FAQ</a> for some recommendations for common issues.</p>
</div>
<div id="getting-ready" class="section level1">
<h1>Getting ready</h1>
<p>First we load the necessary libraries. If you don’t already have the dada2 package, see the <a href="dada-installation.html">dada2 installation instructions</a>. The ShortRead and ggplot2 packages are available from <a href="http://bioconductor.org/install/">Bioconductor</a>:</p>
<pre class="r"><code>library(dada2); packageVersion(&quot;dada2&quot;)</code></pre>
<pre><code>## [1] &#39;1.2.1&#39;</code></pre>
<pre class="r"><code>library(ShortRead); packageVersion(&quot;ShortRead&quot;)</code></pre>
<pre><code>## [1] &#39;1.32.0&#39;</code></pre>
<pre class="r"><code>library(ggplot2); packageVersion(&quot;ggplot2&quot;)</code></pre>
<pre><code>## [1] &#39;2.2.1&#39;</code></pre>
<p><em>If your dada2 version is &lt;1.2.0 you must upgrade to the current release version to run this workflow: <code>biocLite(&quot;dada2&quot;)</code>. This may first require updating your Bioconductor installation: <code>biocLite(&quot;BiocUpgrade&quot;)</code> and reinstalling Bioconductor: <code>biocLite()</code></em></p>
<p>The data we will work with are the same as those in the <a href="http://www.mothur.org/wiki/MiSeq_SOP">Mothur Miseq SOP</a> walkthrough. Download the <a href="http://www.mothur.org/w/images/d/d6/MiSeqSOPData.zip">example data used in the Mother MiSeq SOP</a> and unzip it. These files represent longitudinal samples from a mouse post-weaning as well as one mock community control. But for now just consider them as paired-end fastq files to be processed. Download the data, extract it, and then define the following path variable so that it points to the extracted directory on <strong>your</strong> machine:</p>
<pre class="r"><code>path &lt;- &quot;~/MiSeq_SOP&quot; # CHANGE ME to the directory containing the fastq files after unzipping.
fns &lt;- list.files(path)
fns</code></pre>
<pre><code>##  [1] &quot;F3D0_filtered.fq.gz&quot;           &quot;F3D0_S188_L001_R1_001.fastq&quot;  
##  [3] &quot;F3D0_S188_L001_R2_001.fastq&quot;   &quot;F3D1_filtered.fq.gz&quot;          
##  [5] &quot;F3D1_S189_L001_R1_001.fastq&quot;   &quot;F3D1_S189_L001_R2_001.fastq&quot;  
##  [7] &quot;F3D141_filtered.fq.gz&quot;         &quot;F3D141_S207_L001_R1_001.fastq&quot;
##  [9] &quot;F3D141_S207_L001_R2_001.fastq&quot; &quot;F3D142_filtered.fq.gz&quot;        
## [11] &quot;F3D142_S208_L001_R1_001.fastq&quot; &quot;F3D142_S208_L001_R2_001.fastq&quot;
## [13] &quot;F3D143_filtered.fq.gz&quot;         &quot;F3D143_S209_L001_R1_001.fastq&quot;
## [15] &quot;F3D143_S209_L001_R2_001.fastq&quot; &quot;F3D144_filtered.fq.gz&quot;        
## [17] &quot;F3D144_S210_L001_R1_001.fastq&quot; &quot;F3D144_S210_L001_R2_001.fastq&quot;
## [19] &quot;F3D145_filtered.fq.gz&quot;         &quot;F3D145_S211_L001_R1_001.fastq&quot;
## [21] &quot;F3D145_S211_L001_R2_001.fastq&quot; &quot;F3D146_filtered.fq.gz&quot;        
## [23] &quot;F3D146_S212_L001_R1_001.fastq&quot; &quot;F3D146_S212_L001_R2_001.fastq&quot;
## [25] &quot;F3D147_filtered.fq.gz&quot;         &quot;F3D147_S213_L001_R1_001.fastq&quot;
## [27] &quot;F3D147_S213_L001_R2_001.fastq&quot; &quot;F3D148_filtered.fq.gz&quot;        
## [29] &quot;F3D148_S214_L001_R1_001.fastq&quot; &quot;F3D148_S214_L001_R2_001.fastq&quot;
## [31] &quot;F3D149_filtered.fq.gz&quot;         &quot;F3D149_S215_L001_R1_001.fastq&quot;
## [33] &quot;F3D149_S215_L001_R2_001.fastq&quot; &quot;F3D150_filtered.fq.gz&quot;        
## [35] &quot;F3D150_S216_L001_R1_001.fastq&quot; &quot;F3D150_S216_L001_R2_001.fastq&quot;
## [37] &quot;F3D2_filtered.fq.gz&quot;           &quot;F3D2_S190_L001_R1_001.fastq&quot;  
## [39] &quot;F3D2_S190_L001_R2_001.fastq&quot;   &quot;F3D3_filtered.fq.gz&quot;          
## [41] &quot;F3D3_S191_L001_R1_001.fastq&quot;   &quot;F3D3_S191_L001_R2_001.fastq&quot;  
## [43] &quot;F3D5_filtered.fq.gz&quot;           &quot;F3D5_S193_L001_R1_001.fastq&quot;  
## [45] &quot;F3D5_S193_L001_R2_001.fastq&quot;   &quot;F3D6_filtered.fq.gz&quot;          
## [47] &quot;F3D6_S194_L001_R1_001.fastq&quot;   &quot;F3D6_S194_L001_R2_001.fastq&quot;  
## [49] &quot;F3D7_filtered.fq.gz&quot;           &quot;F3D7_S195_L001_R1_001.fastq&quot;  
## [51] &quot;F3D7_S195_L001_R2_001.fastq&quot;   &quot;F3D8_filtered.fq.gz&quot;          
## [53] &quot;F3D8_S196_L001_R1_001.fastq&quot;   &quot;F3D8_S196_L001_R2_001.fastq&quot;  
## [55] &quot;F3D9_filtered.fq.gz&quot;           &quot;F3D9_S197_L001_R1_001.fastq&quot;  
## [57] &quot;F3D9_S197_L001_R2_001.fastq&quot;   &quot;filtered&quot;                     
## [59] &quot;HMP_MOCK.v35.fasta&quot;            &quot;Mock_filtered.fq.gz&quot;          
## [61] &quot;Mock_S280_L001_R1_001.fastq&quot;   &quot;Mock_S280_L001_R2_001.fastq&quot;  
## [63] &quot;mouse.dpw.metadata&quot;            &quot;mouse.time.design&quot;            
## [65] &quot;stability.batch&quot;               &quot;stability.files&quot;</code></pre>
<p>If the packages successfully loaded and your listed files match those here, then you are ready to go through the DADA2 pipeline.</p>
<p> </p>
</div>
<div id="filtering-and-trimming" class="section level1">
<h1>Filtering and Trimming</h1>
<p>First we read in the names of the fastq files, and perform some string manipulation to get lists of the forward and reverse fastq files in matched order:</p>
<pre class="r"><code>fastqs &lt;- fns[grepl(&quot;.fastq$&quot;, fns)]
fastqs &lt;- sort(fastqs) # Sort ensures forward/reverse reads are in same order
fnFs &lt;- fastqs[grepl(&quot;_R1&quot;, fastqs)] # Just the forward read files
fnRs &lt;- fastqs[grepl(&quot;_R2&quot;, fastqs)] # Just the reverse read files
# Get sample names, assuming files named as so: SAMPLENAME_XXX.fastq
sample.names &lt;- sapply(strsplit(fnFs, &quot;_&quot;), `[`, 1)
# Specify the full path to the fnFs and fnRs
fnFs &lt;- file.path(path, fnFs)
fnRs &lt;- file.path(path, fnRs)</code></pre>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> The string manipulations above, especially the extraction of sample names from the file names, may have to be modified.</p>
<div id="examine-quality-profiles-of-forward-and-reverse-reads" class="section level2">
<h2>Examine quality profiles of forward and reverse reads</h2>
<p>It is important to look at your data. We start by visualizing the quality profiles along the sequencing reads.</p>
<p><strong>Visualize the quality profile of the forward reads</strong>:</p>
<pre class="r"><code>plotQualityProfile(fnFs[[1]])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-F-1.png" width="672" /></p>
<pre class="r"><code>plotQualityProfile(fnFs[[2]])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-F-2.png" width="672" /></p>
<p>The forward reads are good quality. We generally advise trimming the last few nucleotides to avoid less well-controlled errors that can arise there. There is no suggestion from these quality profiles that any additional trimming is needed, so we will truncate the forward reads at position 240 (trimming the last 10 nucleotides).</p>
<p><strong>Visualize the quality profile of the reverse reads</strong>:</p>
<pre class="r"><code>plotQualityProfile(fnRs[[1]])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-R-1.png" width="672" /></p>
<pre class="r"><code>plotQualityProfile(fnRs[[2]])</code></pre>
<p><img src="tutorial_files/figure-html/see-quality-R-2.png" width="672" /></p>
<p>The reverse reads are of significantly worse quality, especially at the end, which is common in Illumina paired-end sequencing. This isn’t too worrisome, DADA2 incorporates quality information into its error model which makes the algorithm is robust to lower quality sequence, but trimming as the average qualities crash is still a good idea. We will truncate at position 160 where the quality distribution crashes.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> Your reads must <strong>overlap after trimming</strong> in order to merge them later! The 2x250 V4 sequence data being analyzed here is almost completely overlapping, thus our trimming can be completely guided by the quality scores. If you are using a less-overlapping primer set, like V1-V2 or V3-V4, you must keep enough of each read to maintain the overlap between them (the more the better).</p>
</div>
<div id="perform-filtering-and-trimming" class="section level2">
<h2>Perform filtering and trimming</h2>
<p>We’ll use standard filtering parameters: <code>maxN=0</code> (DADA2 requires no Ns), <code>truncQ=2</code> and <code>maxEE=2</code>. The <code>maxEE</code> parameter sets the maximum number of “expected errors” allowed in a read, which is <a href="http://www.drive5.com/usearch/manual/expected_errors.html">a better filter than simply averaging quality scores</a>. We use the <code>fastqPairedFilter</code> function to jointly filter the forward and reverse reads.</p>
<p><strong>Filter the forward and reverse reads</strong>:</p>
<pre class="r"><code># Make directory and filenames for the filtered fastqs
filt_path &lt;- file.path(path, &quot;filtered&quot;)
if(!file_test(&quot;-d&quot;, filt_path)) dir.create(filt_path)
filtFs &lt;- file.path(filt_path, paste0(sample.names, &quot;_F_filt.fastq.gz&quot;))
filtRs &lt;- file.path(filt_path, paste0(sample.names, &quot;_R_filt.fastq.gz&quot;))
# Filter
for(i in seq_along(fnFs)) {
  fastqPairedFilter(c(fnFs[i], fnRs[i]), c(filtFs[i], filtRs[i]),
                    truncLen=c(240,160), 
                    maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
                    compress=TRUE, verbose=TRUE)
}</code></pre>
<p>The preceding filtering can be replaced by other filtering methods. However, in order for the later DADA2 <code>mergePairs</code> step to work, the filtered forward and reverse reads must be in matched order. The fastq files that come off the Illumina machine have this property, and <code>fastqPairedFilter</code> preserves it, but not all filtering tools do so.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> The standard filtering parameters are starting points, not set in stone. For example, if too few reads are passing the filter, considering relaxing <code>maxEE</code>, perhaps especially on the reverse reads (eg. <code>maxEE=c(2,5)</code>). If you want to speed up downstream computation, consider tightening <code>maxEE</code>.</p>
<p> </p>
</div>
</div>
<div id="dereplication" class="section level1">
<h1>Dereplication</h1>
<p>Dereplication combines all identical sequencing reads into into “unique sequences” with a corresponding “abundance”: the number of reads with that same sequence. Dereplication substantially reduces computation time by eliminating redundant comparisons.</p>
<p>Dereplication in the DADA2 pipeline has one crucial addition from other pipelines: <strong>DADA2 retains a summary of the quality information associated with each unique sequence</strong>. The consensus quality profile of a unique sequence is the average of the positional qualities from the dereplicated reads. These quality profiles inform the error model of the subsequent denoising step, significantly increasing DADA2’s accuracy.</p>
<p><strong>Dereplicate the filtered fastq files</strong>:</p>
<pre class="r"><code>derepFs &lt;- derepFastq(filtFs, verbose=TRUE)
derepRs &lt;- derepFastq(filtRs, verbose=TRUE)
# Name the derep-class objects by the sample names
names(derepFs) &lt;- sample.names
names(derepRs) &lt;- sample.names</code></pre>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> The tutorial dataset is small enough to easily load into memory. If your dataset exceeds available RAM, it is preferable to process samples one-by-one in a streaming fashion: see the <a href="bigdata.html">DADA2 Workflow on Big Data</a> for an example.</p>
<p> </p>
</div>
<div id="learn-the-error-rates" class="section level1">
<h1>Learn the Error Rates</h1>
<p>The DADA2 algorithm depends on a parametric error model (<code>err</code>) and amplicon dataset will have different error rates. DADA2 learns its error model from the data itself by alternating estimation of the error rates and the composition of the sample until they converge on a jointly consistent solution (this is similar to the E-M algorithm).</p>
<p>To perform this joint inference we run <code>dada</code> with <code>selfConsist=TRUE</code>. As in many optimization problems, the algorithm must begin with an initial guess, for which we provide the maximum possible error rates in this data (the error rates if only the most abundant sequence is correct and all the rest are errors) by setting <code>err=NULL</code>.</p>
<p><em>The following runs in about 4 minutes on a 2013 Macbook Pro:</em></p>
<pre class="r"><code>dadaFs.lrn &lt;- dada(derepFs, err=NULL, selfConsist = TRUE, multithread=TRUE)</code></pre>
<pre><code>## Initial error matrix unspecified. Error rates will be initialized to the maximum possible estimate from this data.</code></pre>
<pre><code>## Initializing error rates to maximum possible estimate.
## Sample 1 - 7113 reads in 1979 unique sequences.
## Sample 2 - 5299 reads in 1639 unique sequences.
## Sample 3 - 5463 reads in 1477 unique sequences.
## Sample 4 - 2914 reads in 904 unique sequences.
## Sample 5 - 2941 reads in 939 unique sequences.
## Sample 6 - 4312 reads in 1267 unique sequences.
## Sample 7 - 6741 reads in 1756 unique sequences.
## Sample 8 - 4560 reads in 1438 unique sequences.
## Sample 9 - 15637 reads in 3590 unique sequences.
## Sample 10 - 11413 reads in 2762 unique sequences.
## Sample 11 - 12017 reads in 3021 unique sequences.
## Sample 12 - 5032 reads in 1566 unique sequences.
## Sample 13 - 18075 reads in 3707 unique sequences.
## Sample 14 - 6250 reads in 1479 unique sequences.
## Sample 15 - 4052 reads in 1195 unique sequences.
## Sample 16 - 7369 reads in 1832 unique sequences.
## Sample 17 - 4765 reads in 1183 unique sequences.
## Sample 18 - 4871 reads in 1382 unique sequences.
## Sample 19 - 6504 reads in 1709 unique sequences.
## Sample 20 - 4314 reads in 897 unique sequences.
##    selfConsist step 2 
##    selfConsist step 3 
##    selfConsist step 4 
##    selfConsist step 5 
## 
## 
## Convergence after  5  rounds.</code></pre>
<pre class="r"><code>errF &lt;- dadaFs.lrn[[1]]$err_out
dadaRs.lrn &lt;- dada(derepRs, err=NULL, selfConsist = TRUE, multithread=TRUE)</code></pre>
<pre><code>## Initial error matrix unspecified. Error rates will be initialized to the maximum possible estimate from this data.</code></pre>
<pre><code>## Initializing error rates to maximum possible estimate.
## Sample 1 - 7113 reads in 1660 unique sequences.
## Sample 2 - 5299 reads in 1349 unique sequences.
## Sample 3 - 5463 reads in 1335 unique sequences.
## Sample 4 - 2914 reads in 853 unique sequences.
## Sample 5 - 2941 reads in 880 unique sequences.
## Sample 6 - 4312 reads in 1286 unique sequences.
## Sample 7 - 6741 reads in 1803 unique sequences.
## Sample 8 - 4560 reads in 1265 unique sequences.
## Sample 9 - 15637 reads in 3414 unique sequences.
## Sample 10 - 11413 reads in 2522 unique sequences.
## Sample 11 - 12017 reads in 2771 unique sequences.
## Sample 12 - 5032 reads in 1415 unique sequences.
## Sample 13 - 18075 reads in 3290 unique sequences.
## Sample 14 - 6250 reads in 1390 unique sequences.
## Sample 15 - 4052 reads in 1134 unique sequences.
## Sample 16 - 7369 reads in 1635 unique sequences.
## Sample 17 - 4765 reads in 1084 unique sequences.
## Sample 18 - 4871 reads in 1161 unique sequences.
## Sample 19 - 6504 reads in 1502 unique sequences.
## Sample 20 - 4314 reads in 732 unique sequences.
##    selfConsist step 2 
##    selfConsist step 3 
##    selfConsist step 4 
##    selfConsist step 5 
##    selfConsist step 6 
## 
## 
## Convergence after  6  rounds.</code></pre>
<pre class="r"><code>errR &lt;- dadaRs.lrn[[1]]$err_out</code></pre>
<p>It is always worthwhile, as a sanity check if nothing else, to visualize the estimated error rates:</p>
<pre class="r"><code>plotErrors(dadaFs.lrn[[1]], nominalQ=TRUE)</code></pre>
<p><img src="tutorial_files/figure-html/plot-errors-1.png" width="672" /></p>
<p>The error rates for each possible transition (eg. A-&gt;C, A-&gt;G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence. The red line is the error rates expected under the nominal definition of the Q-value. Here the black line (the estimated rates) fits the observed rates well, and the error rates drop with increased quality as expected. Everything looks reasonable and we proceed with confidence.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> Parameter learning is the most computationally intensive portion of this workflow as sample inference is re-run for every iteration of the self-consistency loop. For larger datasets it is often preferable to estimate error rates from a subset of the data: see the <a href="bigdata.html">DADA2 Workflow on Big Data</a> for an example.</p>
<p> </p>
</div>
<div id="sample-inference" class="section level1">
<h1>Sample Inference</h1>
<p>We are now ready to apply the core sequence-variant inference algorithm to the dereplicated data.</p>
<p><strong>Infer the sequence variants in each sample</strong>:</p>
<pre class="r"><code>dadaFs &lt;- dada(derepFs, err=errF, multithread=TRUE)</code></pre>
<pre><code>## Sample 1 - 7113 reads in 1979 unique sequences.
## Sample 2 - 5299 reads in 1639 unique sequences.
## Sample 3 - 5463 reads in 1477 unique sequences.
## Sample 4 - 2914 reads in 904 unique sequences.
## Sample 5 - 2941 reads in 939 unique sequences.
## Sample 6 - 4312 reads in 1267 unique sequences.
## Sample 7 - 6741 reads in 1756 unique sequences.
## Sample 8 - 4560 reads in 1438 unique sequences.
## Sample 9 - 15637 reads in 3590 unique sequences.
## Sample 10 - 11413 reads in 2762 unique sequences.
## Sample 11 - 12017 reads in 3021 unique sequences.
## Sample 12 - 5032 reads in 1566 unique sequences.
## Sample 13 - 18075 reads in 3707 unique sequences.
## Sample 14 - 6250 reads in 1479 unique sequences.
## Sample 15 - 4052 reads in 1195 unique sequences.
## Sample 16 - 7369 reads in 1832 unique sequences.
## Sample 17 - 4765 reads in 1183 unique sequences.
## Sample 18 - 4871 reads in 1382 unique sequences.
## Sample 19 - 6504 reads in 1709 unique sequences.
## Sample 20 - 4314 reads in 897 unique sequences.</code></pre>
<pre class="r"><code>dadaRs &lt;- dada(derepRs, err=errR, multithread=TRUE)</code></pre>
<pre><code>## Sample 1 - 7113 reads in 1660 unique sequences.
## Sample 2 - 5299 reads in 1349 unique sequences.
## Sample 3 - 5463 reads in 1335 unique sequences.
## Sample 4 - 2914 reads in 853 unique sequences.
## Sample 5 - 2941 reads in 880 unique sequences.
## Sample 6 - 4312 reads in 1286 unique sequences.
## Sample 7 - 6741 reads in 1803 unique sequences.
## Sample 8 - 4560 reads in 1265 unique sequences.
## Sample 9 - 15637 reads in 3414 unique sequences.
## Sample 10 - 11413 reads in 2522 unique sequences.
## Sample 11 - 12017 reads in 2771 unique sequences.
## Sample 12 - 5032 reads in 1415 unique sequences.
## Sample 13 - 18075 reads in 3290 unique sequences.
## Sample 14 - 6250 reads in 1390 unique sequences.
## Sample 15 - 4052 reads in 1134 unique sequences.
## Sample 16 - 7369 reads in 1635 unique sequences.
## Sample 17 - 4765 reads in 1084 unique sequences.
## Sample 18 - 4871 reads in 1161 unique sequences.
## Sample 19 - 6504 reads in 1502 unique sequences.
## Sample 20 - 4314 reads in 732 unique sequences.</code></pre>
<p>Inspecting the dada-class object returned by dada:</p>
<pre class="r"><code>dadaFs[[1]]</code></pre>
<pre><code>## dada-class: object describing DADA2 denoising results
## 128 sample sequences were inferred from 1979 input unique sequences.
## Key parameters: OMEGA_A = 1e-40, BAND_SIZE = 16, USE_QUALS = TRUE</code></pre>
<p>The DADA2 algorithm inferred 128 real variants from the 1979 unique sequences in the first sample. There is much more to the <code>dada-class</code> return object than this (see <code>help(&quot;dada-class&quot;)</code> for some info), including multiple diagnostics about the quality of each inferred sample sequence, but that is beyond the scope of an introductory tutorial.</p>
<p><strong>Also see <a href="pool.html">our discussion on pooling samples for error estimation and sample inference</a>.</strong></p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> DADA2 also supports 454 and Ion Torrent data, although <a href="faq.html#can-i-use-dada2-with-my-454-or-ion-torrent-data">we recommend some minor parameter changes</a> for those sequencing technologies.</p>
<p> </p>
</div>
<div id="merge-paired-reads" class="section level1">
<h1>Merge paired reads</h1>
<p>Spurious sequence variants can be further reduced by merging these overlapping reads. The core function here is <code>mergePairs</code>, which depends on the forward and reverse reads being in matching order at the time they were dereplicated.</p>
<p><strong>Merge the denoised forward and reverse reads</strong>:</p>
<pre class="r"><code>mergers &lt;- mergePairs(dadaFs, derepFs, dadaRs, derepRs, verbose=TRUE)
# Inspect the merger data.frame from the first sample
head(mergers[[1]])</code></pre>
<pre><code>##                                                                                                                                                                                                                                                          sequence
## s1_1 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGAAGATCAAGTCAGCGGTAAAATTGAGAGGCTCAACCTCTTCGAGCCGTTGAAACTGGTTTTCTTGAGTGAGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCTCAACTGACGCTCATGCACGAAAGTGTGGGTATCGAACAGG
## s2_2 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGCCTGCCAAGTCAGCGGTAAAATTGCGGGGCTCAACCCCGTACAGCCGTTGAAACTGCCGGGCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCAAACAGG
## s3_4 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGCTGTTAAGTCAGCGGTCAAATGTCGGGGCTCAACCCCGGCCTGCCGTTGAAACTGGCGGCCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCCCGACTGACGCTGAGGCACGAAAGCGTGGGTATCGAACAGG
## s4_3 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGCTTTTAAGTCAGCGGTAAAAATTCGGGGCTCAACCCCGTCCGGCCGTTGAAACTGGGGGCCTTGAGTGGGCGAGAAGAAGGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCCTTCCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCGAACAGG
## s5_6 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGACTCTCAAGTCAGCGGTCAAATCGCGGGGCTCAACCCCGTTCCGCCGTTGAAACTGGGAGCCTTGAGTGCGCGAGAAGTAGGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCCTACCGGCGCGCAACTGACGCTCATGCACGAAAGCGTGGGTATCGAACAGG
## s6_5 TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGATGCCAAGTCAGCGGTAAAAAAGCGGTGCTCAACGCCGTCGAGCCGTTGAAACTGGCGTTCTTGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGCGTGGGTATCGAACAGG
##      abundance forward reverse nmatch nmismatch nindel prefer accept
## s1_1       586       1       1    148         0      0      1   TRUE
## s2_2       471       2       2    148         0      0      2   TRUE
## s3_4       451       3       4    148         0      0      1   TRUE
## s4_3       433       4       3    148         0      0      2   TRUE
## s5_6       353       5       6    148         0      0      1   TRUE
## s6_5       285       6       5    148         0      0      2   TRUE</code></pre>
<p>We now have a <code>data.frame</code> for each sample with the merged <code>$sequence</code>, its <code>$abundance</code>, and the indices of the merged <code>$forward</code> and <code>$reverse</code> denoised sequences. Paired reads that did not exactly overlap were removed by <code>mergePairs</code>.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> Most of your <strong>reads</strong> should successfully merge. If that is not the case, upstream parameters may need to be revisited. In particular, did you trim away the overlap between your reads?</p>
<p> </p>
</div>
<div id="constructing-the-sequence-table" class="section level1">
<h1>Constructing the sequence table</h1>
<p>We can now construct a sequence table of our mouse samples that is analagous to the “OTU table” produced by classical methods.</p>
<p><strong>Construct sequence table</strong>:</p>
<pre class="r"><code>seqtab &lt;- makeSequenceTable(mergers[names(mergers) != &quot;Mock&quot;])</code></pre>
<pre><code>## The sequences being tabled vary in length.</code></pre>
<pre class="r"><code>dim(seqtab)</code></pre>
<pre><code>## [1]  19 274</code></pre>
<pre class="r"><code># Inspect distribution of sequence lengths
table(nchar(getSequences(seqtab)))</code></pre>
<pre><code>## 
## 251 252 253 254 255 
##   1  84 182   5   2</code></pre>
<p>The sequence table is a <code>matrix</code> with rows corresponding to (and named by) the samples, and columns corresponding to (and named by) the sequence variants. Our merged sequences all fall in the expected range for these V4 amplicon.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> Sequences that are much longer or shorter than expected may be the result of non-specific priming, and may be worth removing (eg. <code>seqtab2 &lt;- seqtab[,nchar(colnames(seqtab)) %in% seq(250,256)]</code>). This is analogous to “cutting a band” in-silico to get amplicons of the targeted length.</p>
<p> </p>
</div>
<div id="remove-chimeras" class="section level1">
<h1>Remove chimeras</h1>
<p>The core <code>dada</code> method removes substitution and indel errors, but chimeras remain. Fortunately, the accuracy of the sequences after denoising makes identifying chimeras easier than it is when dealing with fuzzy OTUs: all sequences which can be exactly reconstructed as a bimera (two-parent chimera) from more abundant sequences.</p>
<p><strong>Remove chimeric sequences</strong>:</p>
<pre class="r"><code>seqtab.nochim &lt;- removeBimeraDenovo(seqtab, verbose=TRUE)
dim(seqtab.nochim)</code></pre>
<pre><code>## [1]  19 211</code></pre>
<pre class="r"><code>sum(seqtab.nochim)/sum(seqtab)</code></pre>
<pre><code>## [1] 0.9619125</code></pre>
<p>The fraction of chimeras varies based on factors including experimental procedures and sample complexity, but can be substantial. Here chimeras make up about 23% of the inferred sequence variants, but those variants account for only about 4% of the total sequence reads.</p>
<p><strong><span style="color:red">If using this workflow on your own data:</span></strong> Most of your <strong>reads</strong> should remain after chimera removal (it is not uncommon for a majority of <strong>sequence variants</strong> to be removed though). If most of your reads were removed as chimeric, upstream processing may need to be revisited. In almost all cases this is caused by primer sequences with ambiguous nucleotides that were not removed prior to beginning the DADA2 pipeline.</p>
<p> </p>
</div>
<div id="assign-taxonomy" class="section level1">
<h1>Assign taxonomy</h1>
<p>It is common at this point, especially in 16S/18S/ITS amplicon sequencing, to classify sequence variants taxonomically. The DADA2 package provides a native implementation of <a href="http://www.ncbi.nlm.nih.gov/pubmed/17586664">the RDP’s naive Bayesian classifier</a> for this purpose. The <code>assignTaxonomy</code> function takes a set of sequences and a training set of taxonomically classified sequences, and outputs the taxonomic assignments with at least <code>minBoot</code> bootstrap confidence.</p>
<p>Appropriately formatted training fastas for the <a href="http://dx.doi.org/10.5281/zenodo.158955">RDP training set 14</a>, the <a href="http://dx.doi.org/10.5281/zenodo.158955">GreenGenes 13.8 release clustered at 97% identity</a>, the <a href="http://dx.doi.org/10.5281/zenodo.158958">Silva reference database v123</a> (<a href="http://dx.doi.org/10.5281/zenodo.158958">Silva dual license</a>), and the <a href="https://unite.ut.ee/repository.php">UNITE ITS database</a> (use the General Fasta release files) are available. To follow along, download the <code>rdp_train_set_14.fa.gz</code> file, and place it in the directory with the fastq files.</p>
<p><strong>Assign taxonomy:</strong></p>
<pre class="r"><code>taxa &lt;- assignTaxonomy(seqtab.nochim, &quot;rdp_train_set_14.fa.gz&quot;)
unname(head(taxa))</code></pre>
<pre><code>##      [,1]       [,2]            [,3]          [,4]           
## [1,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
## [2,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
## [3,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
## [4,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
## [5,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
## [6,] &quot;Bacteria&quot; &quot;Bacteroidetes&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot;
##      [,5]                 [,6]         
## [1,] &quot;Porphyromonadaceae&quot; NA           
## [2,] &quot;Porphyromonadaceae&quot; NA           
## [3,] &quot;Porphyromonadaceae&quot; &quot;Barnesiella&quot;
## [4,] &quot;Porphyromonadaceae&quot; &quot;Barnesiella&quot;
## [5,] &quot;Bacteroidaceae&quot;     &quot;Bacteroides&quot;
## [6,] &quot;Porphyromonadaceae&quot; &quot;Barnesiella&quot;</code></pre>
<p>Unsurprisingly, the Bacteroidetes are well represented among the most abundant taxa in these fecal samples.</p>
<p><em><a href="assign.html#species-assignment">Species-level assignment using exact matching</a> is also available.</em></p>
<p> </p>
</div>
<div id="evaluate-accuracy" class="section level1">
<h1>Evaluate accuracy</h1>
<p>One of the processed samples was a “mock community”, in which a mixture of 20 known strains was sequenced (this mock community is supposed to be 21 strains, but <em>P. acnes</em> was absent). Reference sequences corresponding to these strains were provided in the downloaded zip archive. We dropped the Mock sample when making our sequence table, but we return to that sample and compare the sequence variants inferred by DADA2 to the expected composition of the community.</p>
<p><strong>Evaluating DADA2’s accuracy on the mock community</strong>:</p>
<pre class="r"><code>unqs.mock &lt;- getUniques(removeBimeraDenovo(mergers[[&quot;Mock&quot;]], verbose=TRUE))</code></pre>
<pre><code>## Identified 0 bimeras out of 20 input sequences.</code></pre>
<pre class="r"><code>cat(&quot;DADA2 inferred&quot;, length(unqs.mock), &quot;sample sequences present in the Mock community.\n&quot;)</code></pre>
<pre><code>## DADA2 inferred 20 sample sequences present in the Mock community.</code></pre>
<pre class="r"><code>mockRef &lt;- readFasta(file.path(path, &quot;HMP_MOCK.v35.fasta&quot;))
match.ref &lt;- sum(sapply(names(unqs.mock), function(x) any(grepl(x, as.character(sread(mockRef))))))
cat(&quot;Of those,&quot;, sum(match.ref), &quot;were exact matches to the expected reference sequences.\n&quot;)</code></pre>
<pre><code>## Of those, 20 were exact matches to the expected reference sequences.</code></pre>
<p>This mock community dataset contained <strong>20</strong> bacterial strains. DADA2 found <strong>20</strong> unique sequences all of which <strong>exactly</strong> match the reference genomes of the expected community members. The residual error rate after the DADA2 pipeline for this sample is <strong>0%</strong>.</p>
<p>In comparison, <a href="http://www.mothur.org/wiki/MiSeq_SOP#Assessing_error_rates">the mothur pipeline finds 34 OTUs in this Mock community sample</a>. DADA2 infers sequence variants exactly instead of fuzzy 97% OTUs, and outputs fewer false positives than the OTU methods!</p>
<p><strong>Here ends the DADA2 portion of the tutorial</strong>.</p>
<hr />
</div>
<div id="bonus-handoff-to-phyloseq" class="section level1">
<h1>Bonus: Handoff to phyloseq</h1>
<p>The DADA2 pipeline produced a sequence table and a taxonomy table which is appropriate for further analysis in phyloseq. We’ll also include the small amount of metadata we have – the samples are named by the gender (G), mouse subject number (X) and the day post-weaning (Y) it was sampled (eg. GXDY).</p>
<p><strong>Import into phyloseq</strong>:</p>
<pre class="r"><code>library(phyloseq); packageVersion(&quot;phyloseq&quot;)</code></pre>
<pre><code>## [1] &#39;1.19.1&#39;</code></pre>
<pre class="r"><code>library(ggplot2); packageVersion(&quot;ggplot2&quot;)</code></pre>
<pre><code>## [1] &#39;2.2.1&#39;</code></pre>
<pre class="r"><code># Make a data.frame holding the sample data
samples.out &lt;- rownames(seqtab.nochim)
subject &lt;- sapply(strsplit(samples.out, &quot;D&quot;), `[`, 1)
gender &lt;- substr(subject,1,1)
subject &lt;- substr(subject,2,999)
day &lt;- as.integer(sapply(strsplit(samples.out, &quot;D&quot;), `[`, 2))
samdf &lt;- data.frame(Subject=subject, Gender=gender, Day=day)
samdf$When &lt;- &quot;Early&quot;
samdf$When[samdf$Day&gt;100] &lt;- &quot;Late&quot;
rownames(samdf) &lt;- samples.out

# Construct phyloseq object (straightforward from dada2 outputs)
ps &lt;- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps</code></pre>
<pre><code>## phyloseq-class experiment-level object
## otu_table()   OTU Table:         [ 211 taxa and 19 samples ]
## sample_data() Sample Data:       [ 19 samples by 4 sample variables ]
## tax_table()   Taxonomy Table:    [ 211 taxa by 6 taxonomic ranks ]</code></pre>
<p>We are now ready to use phyloseq.</p>
<p><strong>Visualize alpha-diversity</strong>:</p>
<pre class="r"><code>plot_richness(ps, x=&quot;Day&quot;, measures=c(&quot;Shannon&quot;, &quot;Simpson&quot;), color=&quot;When&quot;) + theme_bw()</code></pre>
<p><img src="tutorial_files/figure-html/richness-1.png" width="672" /></p>
<p>No obvious systematic difference in alpha-diversity between early and late samples.</p>
<p><strong>Ordinate</strong>:</p>
<pre class="r"><code>ord.nmds.bray &lt;- ordinate(ps, method=&quot;NMDS&quot;, distance=&quot;bray&quot;)</code></pre>
<pre><code>## Square root transformation
## Wisconsin double standardization
## Run 0 stress 0.08852629 
## Run 1 stress 0.1590864 
## Run 2 stress 0.1578273 
## Run 3 stress 0.08984917 
## Run 4 stress 0.08984905 
## Run 5 stress 0.08984921 
## Run 6 stress 0.08852635 
## ... Procrustes: rmse 4.074012e-05  max resid 9.805649e-05 
## ... Similar to previous best
## Run 7 stress 0.09019098 
## Run 8 stress 0.08852629 
## ... New best solution
## ... Procrustes: rmse 3.668409e-05  max resid 0.0001131507 
## ... Similar to previous best
## Run 9 stress 0.1569271 
## Run 10 stress 0.1488288 
## Run 11 stress 0.1581764 
## Run 12 stress 0.08852636 
## ... Procrustes: rmse 0.0001132157  max resid 0.0003679305 
## ... Similar to previous best
## Run 13 stress 0.08852629 
## ... Procrustes: rmse 1.022047e-05  max resid 2.560293e-05 
## ... Similar to previous best
## Run 14 stress 0.08852631 
## ... Procrustes: rmse 5.064022e-05  max resid 0.0001600947 
## ... Similar to previous best
## Run 15 stress 0.08852647 
## ... Procrustes: rmse 5.879334e-05  max resid 0.0001283903 
## ... Similar to previous best
## Run 16 stress 0.08984929 
## Run 17 stress 0.08852637 
## ... Procrustes: rmse 0.000118141  max resid 0.0003830733 
## ... Similar to previous best
## Run 18 stress 0.3699655 
## Run 19 stress 0.1581811 
## Run 20 stress 0.0898491 
## *** Solution reached</code></pre>
<pre class="r"><code>plot_ordination(ps, ord.nmds.bray, color=&quot;When&quot;, title=&quot;Bray NMDS&quot;)</code></pre>
<p><img src="tutorial_files/figure-html/ordinate-1.png" width="672" /></p>
<p>Ordination picks out a clear separation between the early and late samples.</p>
<p><strong>Bar plot</strong>:</p>
<pre class="r"><code>top20 &lt;- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 &lt;- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 &lt;- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x=&quot;Day&quot;, fill=&quot;Family&quot;) + facet_wrap(~When, scales=&quot;free_x&quot;)</code></pre>
<p><img src="tutorial_files/figure-html/bar-plot-1.png" width="672" /></p>
<p>Nothing glaringly obvious jumps out from the taxonomic distribution of the top 20 sequences to explain the early-late differentiation.</p>
<p>This was just a bare bones demonstration of how the data from DADA2 can be easily imported into phyloseq and interrogated. For further examples on the many analyses possible with phyloseq, see <a href="https://joey711.github.io/phyloseq/">the phyloseq web site</a>!</p>
</div>

<div class="container" style="width: 100%;color:grey;text-align:right">
  <hr>
  Maintained by Benjamin Callahan (benjamin DOT j DOT callahan AT gmail DOT com)
</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
