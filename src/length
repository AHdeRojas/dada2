RcppExports.cpp:// Generated by using Rcpp::compileAttributes() -> do not edit by hand
RcppExports.cpp:// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
Rmain.cpp://------------------------------------------------------------------
Rmain.cpp:  if(minlen <= KMER_SIZE) { Rcpp::stop("Input sequences must all be longer than the kmer-size (%i).", KMER_SIZE); }
Rmain.cpp:  // https://stackoverflow.com/questions/6121792/how-to-check-if-a-cpu-supports-the-sse3-instruction-set
Rmain.cpp:    raws[index]->index = index;
Rmain.cpp:    raw->kmer8 = &k8[index*n_kmer];
Rmain.cpp:    assign_kmer8(raw->kmer8, raw->seq, KMER_SIZE);
Rmain.cpp:    raw->kmer = &k16[index*n_kmer];
Rmain.cpp:    assign_kmer(raw->kmer, raw->seq, KMER_SIZE);
Rmain.cpp:    raw->kord = &kord[index*maxlen];
Rmain.cpp:    assign_kmer_order(raw->kord, raw->seq, KMER_SIZE);
Rmain.cpp:  Sub **subs = (Sub **) malloc(bb->nraw * sizeof(Sub *)); //E
Rmain.cpp:  Sub **birth_subs = (Sub **) malloc(bb->nclust * sizeof(Sub *)); //E
Rmain.cpp:  for(i=0;i<bb->nclust;i++) {
Rmain.cpp:    for(r=0;r<bb->bi[i]->nraw;r++) {
Rmain.cpp:      raw = bb->bi[i]->raw[r];
Rmain.cpp:      subs[raw->index] = sub_new(bb->bi[i]->center, raw, match, mismatch, gap, homo_gap, false, 1.0, band_size, vectorized_alignment, SSE, gapless);
Rmain.cpp:      birth_subs[i] = sub_new(bb->bi[bb->bi[i]->birth_comp.i]->center, bb->bi[i]->center, match, mismatch, gap, homo_gap, false, 1.0, band_size, vectorized_alignment, SSE, gapless);
Rmain.cpp:  for(index=0;index<bb->nraw;index++) {
Rmain.cpp:  for(i=0;i<bb->nclust;i++) {
Rmain.cpp:  for(i=0;i<bb->nclust;i++) {
Rmain.cpp:    for(r=0;r<bb->bi[i]->nraw;r++) {
Rmain.cpp:      Rmap(bb->bi[i]->raw[r]->index) = i+1; // +1 for R 1-indexing
Rmain.cpp:  b_p_update(bb);       // Calculates abundance p-value for each raw in its cluster (consensuses)
Rmain.cpp:  if(max_clust < 1) { max_clust = bb->nraw; }
Rmain.cpp:  while( (bb->nclust < max_clust) && (newi = b_bud(bb, min_fold, min_hamming, min_abund, verbose)) ) {
Rmain.cpp:    if(verbose) Rprintf("----------- New Cluster C%i -----------\n", newi);
Rmain.cpp:  } // while( (bb->nclust < max_clust) && (newi = b_bud(bb, min_fold, min_hamming, min_abund, verbose)) )
Rmain.cpp:  if(verbose) Rprintf("\nALIGN: %i aligns, %i shrouded (%i raw).\n", bb->nalign, bb->nshroud, bb->nraw);
chimera.cpp://------------------------------------------------------------------
chimera.cpp:    if((left+right) >= sq.size()) { // Toss id/pure-shift/internal-indel "parents"
chimera.cpp:    // Need to evaluate whether parents are allowed for one-off models
chimera.cpp:      std::fill(lefts.begin(), lefts.end(), -1);
chimera.cpp:      std::fill(rights.begin(),rights.end(),-1);
chimera.cpp:        std::fill(lefts_oo.begin(), lefts_oo.end(), -1);
chimera.cpp:        std::fill(rights_oo.begin(),rights_oo.end(),-1);
chimera.cpp:              } else {  // Ignore id/pure-shift/internal-indel "parents"
chimera.cpp:  // matrix stored in "column-major" order (so 1st col, then 2nd col...)
chimera.cpp:  // mat(i,j) --> vals[i+j*nrow]
chimera.cpp:  gap1 = (seq1[i]=='-'); 
chimera.cpp:  gap2 = (seq2[i]=='-');
chimera.cpp:    gap1 = (gap1 && (seq1[i]=='-'));
chimera.cpp:    gap2 = (gap2 && (seq2[i]=='-'));
chimera.cpp:  j=len-1;
chimera.cpp:  gap1 = (seq1[j]=='-'); 
chimera.cpp:  gap2 = (seq2[j]=='-');
chimera.cpp:    j--;
chimera.cpp:    gap1 = (gap1 && (seq1[j]=='-'));
chimera.cpp:    gap2 = (gap2 && (seq2[j]=='-'));
chimera.cpp:  while(al[0][pos] == '-' && pos<len) {
chimera.cpp:  while(al[1][pos] == '-' && pos<max_shift) {
chimera.cpp:    pos++; left++; // Credit as ends-free coverage until parent starts
chimera.cpp:    // Step forward, and credit to one-off further matches (and this mismatch if not a gap)
chimera.cpp:    if(pos<len && al[0][pos] != '-') { left_oo++; }
chimera.cpp:  pos=len-1; right=0;
chimera.cpp:  while(al[0][pos] == '-' && pos >= 0) { 
chimera.cpp:    pos--;
chimera.cpp:  while(al[1][pos] == '-' && pos>+(len-max_shift)) {
chimera.cpp:    pos--; right++;
chimera.cpp:    pos--; right++;
chimera.cpp:    // Step forward, and credit to one-off further matches (and this mismatch if not a gap)
chimera.cpp:    pos--;
chimera.cpp:    if(pos>=0 && al[0][pos] != '-') { right_oo++; }
chimera.cpp:      pos--; right_oo++;
cluster.cpp://  Raw *center = b->bi[i]->center;
cluster.cpp://  uint8_t *center_kmer8 = center->kmer8; // Store original kmer8 pointer
cluster.cpp:  cached=CACHE_STRIDE-1;
cluster.cpp:  if(cached < b->nraw) {
cluster.cpp:    memcpy(kcache, b->raw[cached]->kmer8, n_kmer);
cluster.cpp:    memcpy(b->raw[cached]->kmer8, center->kmer8, n_kmer);
cluster.cpp:    center->kmer8 = b->raw[cached]->kmer8;
cluster.cpp:  center_reads = b->bi[i]->center->reads;
cluster.cpp:  for(index=0, cind=0; index<b->nraw; index++) {
cluster.cpp:    raw = b->raw[index];
cluster.cpp:      memcpy(raw->kmer8, kcache, n_kmer);
cluster.cpp:      if((cached+=CACHE_STRIDE) < b->nraw) { // Move cache forward
cluster.cpp:        memcpy(kcache, raw->kmer8, n_kmer);
cluster.cpp:        memcpy(raw->kmer8, center_kmer8, n_kmer);
cluster.cpp:        center->kmer8 = b->raw[cached]->kmer8;
cluster.cpp:        center->kmer8 = center_kmer8;
cluster.cpp:    if(raw->reads > center_reads) {
cluster.cpp:      sub = sub_new(b->bi[i]->center, raw, match, mismatch, gap_pen, homo_gap_pen, use_kmers, kdist_cutoff, band_size, vectorized_alignment, SSE, gapless);
cluster.cpp:      b->nalign++;
cluster.cpp:      if(!sub) { b->nshroud++; }
cluster.cpp:    lambda = compute_lambda(raw, sub, errMat, b->use_quals, errMat.ncol());
cluster.cpp:    if(index == b->bi[i]->center->index) { b->bi[i]->self = lambda; }
cluster.cpp:    if(lambda * b->reads > raw->E_minmax) { // This cluster could attract this raw
cluster.cpp:      if(lambda * b->bi[i]->center->reads > raw->E_minmax) { // Better E_minmax, set
cluster.cpp:        raw->E_minmax = lambda * b->bi[i]->center->reads;
cluster.cpp:      comp.hamming = sub->nsubs;
cluster.cpp:      b->bi[i]->comp.push_back(comp);
cluster.cpp:      if(i==0 || raw == b->bi[i]->center) { // Update on init (i=0) or if the center (as b_bud doesn't update raw->comp)
cluster.cpp:        raw->comp = comp;
cluster.cpp:      raw = b->raw[index];
cluster.cpp:      if(raw->reads > b->bi[i]->center->reads) {
cluster.cpp:      } else if(raw->p > 0.5) {
cluster.cpp:        sub = sub_new(b->bi[i]->center, raw, match, mismatch, gap_pen, homo_gap_pen, use_kmers, kdist_cutoff, band_size, vectorized_alignment, SSE, gapless);
cluster.cpp:      output[index].lambda = compute_lambda_ts(raw, sub, ncol, err_mat, b->use_quals);
cluster.cpp:        output[index].hamming = sub->nsubs;
cluster.cpp:        output[index].hamming = -1;
cluster.cpp:  // Make thread-safe C-array for the error rate matrix
cluster.cpp:  Comparison *comps = (Comparison *) malloc(sizeof(Comparison) * b->nraw);
cluster.cpp:  RcppParallel::parallelFor(0, b->nraw, compareParallel, GRAIN_SIZE);
cluster.cpp:  for(index=0, cind=0; index<b->nraw; index++) {
cluster.cpp:    b->nalign++; ///t
cluster.cpp:    raw = b->raw[index];
cluster.cpp:    if(lambda<0 || lambda>1) Rcpp::stop("Lambda out-of-range error.");
cluster.cpp:    // Store self-lambda
cluster.cpp:    if(index == b->bi[i]->center->index) { 
cluster.cpp:      b->bi[i]->self = lambda; 
cluster.cpp:    if(lambda * b->reads > raw->E_minmax) { // This cluster could attract this raw
cluster.cpp:      if(lambda * b->bi[i]->center->reads > raw->E_minmax) { // Better E_minmax, set
cluster.cpp:        raw->E_minmax = lambda * b->bi[i]->center->reads;
cluster.cpp:      b->bi[i]->comp.push_back(comp);
cluster.cpp:      if(i==0 || raw == b->bi[i]->center) { // Update on init (i=0) or if the center (as b_bud doesn't update raw->comp)
cluster.cpp:        raw->comp = comp;
cluster.cpp:  double *emax = (double *) malloc(b->nraw * sizeof(double)); //E
cluster.cpp:  Comparison **compmax = (Comparison **) malloc(b->nraw * sizeof(Comparison *)); //E
cluster.cpp:  for(index=0;index<b->nraw;index++) {
cluster.cpp:    compmax[index] = &b->bi[0]->comp[index];
cluster.cpp:    emax[index] = compmax[index]->lambda * b->bi[0]->reads;
cluster.cpp:  for(i=1;i<b->nclust;i++) {
cluster.cpp:    for(cind=0;cind<b->bi[i]->comp.size();cind++) {
cluster.cpp:      comp = &b->bi[i]->comp[cind];
cluster.cpp:      index = comp->index;
cluster.cpp:      e = comp->lambda * b->bi[i]->reads;
cluster.cpp:  for(i=0;i<b->nclust;i++) {
cluster.cpp:    for(int r=b->bi[i]->nraw-1; r>=0; r--) {
cluster.cpp:      raw = b->bi[i]->raw[r];
cluster.cpp:      if(compmax[raw->index]->i != i) {
cluster.cpp:        if(raw->index == b->bi[i]->center->index) {  // Check if center
cluster.cpp:        bi_pop_raw(b->bi[i], r);
cluster.cpp:        bi_add_raw(b->bi[compmax[raw->index]->i], raw);
cluster.cpp:        raw->comp = *compmax[raw->index];
cluster.cpp:    } // for(r=0;r<b->bi[i]->nraw;r++)
cluster.cpp: Calculates the abundance p-value for each raw in the clustering.
cluster.cpp:  for(i=0;i<b->nclust;i++) {
cluster.cpp:    if(b->bi[i]->update_e) {
cluster.cpp:      for(r=0;r<b->bi[i]->nraw;r++) {
cluster.cpp:        raw = b->bi[i]->raw[r];
cluster.cpp:        raw->p = get_pA(raw, b->bi[i]);
cluster.cpp:      } // for(r=0;r<b->bi[i]->nraw;r++)
cluster.cpp:      b->bi[i]->update_e = false;
cluster.cpp:  } // for(i=0;i<b->nclust;i++)
cluster.cpp: Finds the minimum p-value. If significant, creates a new cluster and moves the
cluster.cpp: raws from the raw with the minimum p-value to the new cluster.
cluster.cpp:  int mini = -1, minr = -1, mini_prior = -1, minr_prior = -1; // Negative initialization
cluster.cpp:  minraw = b->bi[0]->center; // Assumes that complete alignment/pval calcs were performed in the init cluster
cluster.cpp:  minraw_prior = b->bi[0]->center; // Assumes that complete alignment/pval calcs were performed in the init cluster
cluster.cpp:  for(i=0;i<b->nclust;i++) {
cluster.cpp:    for(r=1; r<b->bi[i]->nraw; r++) { // r=0 is the center
cluster.cpp:      raw = b->bi[i]->raw[r];
cluster.cpp:///      if(b->bi[i]->center->index == raw->index) { continue; } // Don't bud centers
cluster.cpp:      if(raw->reads < min_abund) { continue; }
cluster.cpp:      hamming = raw->comp.hamming;
cluster.cpp:      lambda = raw->comp.lambda;
cluster.cpp:      // Calculate the fold over-abundance and the hamming distance to this raw
cluster.cpp:        if(min_fold <= 1 || ((double) raw->reads) >= min_fold * lambda * b->bi[i]->reads) {  
cluster.cpp:          if((raw->p < minraw->p) ||
cluster.cpp:             ((raw->p == minraw->p && raw->reads > minraw->reads))) { // Most significant
cluster.cpp:          if(raw->prior && ((raw->p < minraw_prior->p) ||
cluster.cpp:             (raw->p == minraw_prior->p && raw->reads > minraw_prior->reads))) { // Most significant
cluster.cpp:///!  Rprintf("Prior... index: %i, i:%i, r:%i, p:%.2e\n", minraw_prior->index, mini_prior, minr_prior, minraw_prior->p); ///!
cluster.cpp:  pA = minraw->p * b->nraw;
cluster.cpp:  pP = minraw_prior->p;
cluster.cpp:  if(pA < b->omegaA && mini >= 0) {  // A significant abundance pval
cluster.cpp:    expected = minraw->comp.lambda * b->bi[mini]->reads;
cluster.cpp:    raw = bi_pop_raw(b->bi[mini], minr);
cluster.cpp:    i = b_add_bi(b, bi_new(b->nraw));
cluster.cpp:    strcpy(b->bi[i]->birth_type, "A");
cluster.cpp:    b->bi[i]->birth_pval = pA;
cluster.cpp:    b->bi[i]->birth_fold = raw->reads/expected;
cluster.cpp:    b->bi[i]->birth_e = expected;
cluster.cpp:    b->bi[i]->birth_comp = minraw->comp;
cluster.cpp:    bi_add_raw(b->bi[i], raw);
cluster.cpp:    bi_assign_center(b->bi[i]);
cluster.cpp:  } else if (pP < b->omegaP && mini_prior >= 0) {  // A significant prior-abundance pval
cluster.cpp:    expected = minraw_prior->comp.lambda * b->bi[mini_prior]->reads;
cluster.cpp:    raw = bi_pop_raw(b->bi[mini_prior], minr_prior);
cluster.cpp:    i = b_add_bi(b, bi_new(b->nraw));
cluster.cpp:    strcpy(b->bi[i]->birth_type, "P");
cluster.cpp:    b->bi[i]->birth_pval = pP;
cluster.cpp:    b->bi[i]->birth_fold = raw->reads/expected;
cluster.cpp:    b->bi[i]->birth_e = expected;
cluster.cpp:    b->bi[i]->birth_comp = minraw_prior->comp;
cluster.cpp:    bi_add_raw(b->bi[i], raw);
cluster.cpp:    bi_assign_center(b->bi[i]);
cluster.cpp:  for(r=0;r<bi->nraw;r++) {
cluster.cpp:    reads += bi->raw[r]->reads;
cluster.cpp:  if(reads != bi->reads) {
cluster.cpp:    bi->update_e = true;
cluster.cpp:  bi->reads = reads;
cluster.cpp:  bi->nraw = nraw;
cluster.cpp:// This function also currently assigns the cluster sequence (equal to center->seq).
cluster.cpp:  bi->center = NULL;
cluster.cpp:  for(r=0,max_reads=0;r<bi->nraw;r++) {
cluster.cpp:    if(bi->raw[r]->reads > max_reads) { // Most abundant
cluster.cpp:      bi->center = bi->raw[r];
cluster.cpp:      max_reads = bi->center->reads;
cluster.cpp:  // Assign center sequence to bi->seq
cluster.cpp:  if(bi->center) { strcpy(bi->seq, bi->center->seq); }
containers.cpp:  raw->seq = (char *) malloc(strlen(seq)+1); //E
containers.cpp:  if (raw->seq == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:  strcpy(raw->seq, seq);
containers.cpp:  raw->length = strlen(seq);
containers.cpp:  raw->reads = reads;
containers.cpp:  raw->prior = prior;
containers.cpp:    raw->qual = (uint8_t *) malloc(raw->length * sizeof(uint8_t)); //E
containers.cpp:    if (raw->qual == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:    for(size_t i=0;i<raw->length;i++) { raw->qual[i] = (uint8_t) round(qual[i]); }
containers.cpp:    raw->qual = NULL;
containers.cpp:  raw->E_minmax = -999.0;
containers.cpp:  free(raw->seq);
containers.cpp:  if(raw->qual) { free(raw->qual); }
containers.cpp:  bi->raw = (Raw **) malloc(RAWBUF * sizeof(Raw *)); //E
containers.cpp:  if (bi->raw == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:  bi->maxraw = RAWBUF;
containers.cpp:  bi->totraw = totraw;
containers.cpp:  bi->center = NULL;
containers.cpp:  strcpy(bi->seq, "");
containers.cpp:  bi->update_e = true;
containers.cpp:  bi->shuffle = true;
containers.cpp:  bi->reads = 0;
containers.cpp:  bi->nraw = 0;
containers.cpp:  free(bi->raw);
containers.cpp:  b->bi = (Bi **) malloc(CLUSTBUF * sizeof(Bi *)); //E
containers.cpp:  if (b->bi == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:  b->maxclust = CLUSTBUF;
containers.cpp:  b->nclust = 0;
containers.cpp:  b->reads = 0;
containers.cpp:  b->nraw = nraw;
containers.cpp:  b->omegaA = omegaA;
containers.cpp:  b->omegaP = omegaP;
containers.cpp:  b->use_quals = use_quals;
containers.cpp:  b->raw = raws;
containers.cpp:  for (index = 0; index < b->nraw; index++) {
containers.cpp:    b->raw[index]->index = index;
containers.cpp:    b->reads += b->raw[index]->reads;
containers.cpp:  for(i=0; i<b->nclust; i++) {
containers.cpp:    bi_free(b->bi[i]);
containers.cpp:  b->nclust=0;
containers.cpp:  b_add_bi(b, bi_new(b->nraw));
containers.cpp:  strcpy(b->bi[0]->birth_type, "I");
containers.cpp:  b->bi[0]->birth_pval = 0.0;
containers.cpp:  b->bi[0]->birth_fold = 1.0;
containers.cpp:  b->bi[0]->birth_e = b->reads;
containers.cpp:  b->nalign = 0;
containers.cpp:  b->nshroud = 0;
containers.cpp:  for (index=0; index<b->nraw; index++) {
containers.cpp:    bi_add_raw(b->bi[0], b->raw[index]);
containers.cpp:  bi_census(b->bi[0]);
containers.cpp:  bi_assign_center(b->bi[0]); // Makes cluster center sequence
containers.cpp:  for(int i=0;i<b->nclust;i++) { bi_free(b->bi[i]); }
containers.cpp:  free(b->bi);
containers.cpp:  if(bi->nraw >= bi->maxraw) {    // Extend Raw* buffer
containers.cpp:    bi->raw = (Raw **) realloc(bi->raw, (bi->maxraw+RAWBUF) * sizeof(Raw *)); //E
containers.cpp:    if (bi->raw == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:    bi->maxraw+=RAWBUF;
containers.cpp:  bi->raw[bi->nraw] = raw;
containers.cpp:  bi->reads += raw->reads;
containers.cpp:  bi->update_e = true;
containers.cpp:  return(bi->nraw++);
containers.cpp:  if(b->nclust >= b->maxclust) {    // Extend Bi* buffer
containers.cpp:    b->bi = (Bi **) realloc(b->bi, (b->maxclust+CLUSTBUF) * sizeof(Bi *)); //E
containers.cpp:    if (b->bi == NULL)  Rcpp::stop("Memory allocation failed.");
containers.cpp:    b->maxclust+=CLUSTBUF;
containers.cpp:  b->bi[b->nclust] = bi;
containers.cpp:  bi->i = b->nclust;
containers.cpp:  return(b->nclust++);
containers.cpp:  if(r<bi->nraw) {
containers.cpp:    pop = bi->raw[r];
containers.cpp:    bi->raw[r] = bi->raw[bi->nraw-1]; // POPPED RAW REPLACED BY LAST RAW
containers.cpp:    bi->raw[bi->nraw-1] = NULL;
containers.cpp:    bi->nraw--;
containers.cpp:    bi->reads -= pop->reads;
containers.cpp:    bi->update_e = true;
containers.cpp:    Rcpp::stop("Container Error (Bi): Tried to pop out-of-range raw.");
error.cpp:  // Create output character-vector of representative sequences for each partition (Bi)
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    for(r=0;r<b->bi[i]->nraw;r++) {
error.cpp:      if(b->bi[i]->raw[r]->reads > max_reads) {
error.cpp:        max_raw = b->bi[i]->raw[r];
error.cpp:        max_reads = max_raw->reads;
error.cpp:      ntcpy(oseq, max_raw->seq);
error.cpp:  Rcpp::IntegerVector Rabunds(b->nclust);      // abundances
error.cpp:  Rcpp::IntegerVector Rzeros(b->nclust);       // n0
error.cpp:  Rcpp::IntegerVector Rones(b->nclust);        // n1
error.cpp:  Rcpp::IntegerVector Rraws(b->nclust);        // nraw
error.cpp:  Rcpp::NumericVector Rbirth_pvals(b->nclust); // pvalue at birth
error.cpp:  Rcpp::NumericVector Rbirth_folds(b->nclust); // fold over-abundance at birth
error.cpp:  Rcpp::IntegerVector Rbirth_hams(b->nclust);  // hamming distance at birth
error.cpp:  Rcpp::NumericVector Rbirth_es(b->nclust);    // expected number at birth
error.cpp:  Rcpp::NumericVector Rbirth_qaves(b->nclust); // average quality of substitutions that drove birth
error.cpp:  Rcpp::NumericVector Rpvals(b->nclust);       // post-hoc pvalue
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    Rabunds[i] = b->bi[i]->reads;
error.cpp:    Rraws[i] = b->bi[i]->nraw;
error.cpp:    for(r=0;r<b->bi[i]->nraw;r++) {
error.cpp:      sub = subs[b->bi[i]->raw[r]->index];
error.cpp:        if(sub->nsubs == 0) { Rzeros[i] += b->bi[i]->raw[r]->reads; }
error.cpp:        if(sub->nsubs == 1) { Rones[i] += b->bi[i]->raw[r]->reads; }
error.cpp:    Rbirth_types.push_back(std::string(b->bi[i]->birth_type));
error.cpp:    if(i==0) {  // 0-clust wasn't born normally
error.cpp:      Rbirth_pvals[i] = b->bi[i]->birth_pval;
error.cpp:      Rbirth_folds[i] = b->bi[i]->birth_fold;
error.cpp:      Rbirth_hams[i] = b->bi[i]->birth_comp.hamming;
error.cpp:      Rbirth_es[i] = b->bi[i]->birth_e;
error.cpp:        if(sub && sub->q1) {
error.cpp:          for(s=0;s<sub->nsubs;s++) {
error.cpp:            q_ave += (sub->q1[s]); // Numeric vector for output
error.cpp:          q_ave = q_ave/((double)sub->nsubs);
error.cpp:  // Calculate post-hoc pval
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    center_of[b->bi[i]->center->index] = i;
error.cpp:  std::vector<double> tot_e(b->nclust);
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    for(cind=0;cind<b->bi[i]->comp.size();cind++) {
error.cpp:      index = b->bi[i]->comp[cind].index;
error.cpp:          tot_e[j] += b->bi[i]->comp[cind].lambda * b->bi[i]->reads;
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    Rpvals[i] = calc_pA(b->bi[i]->reads, tot_e[i], true); // prior=true to get non-conditional p-val
error.cpp:  // Storage for counts for 0...(ncol-1) and each nti->ntj
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    center = b->bi[i]->center;
error.cpp:    for(r=0;r<b->bi[i]->nraw;r++) {
error.cpp:      raw = b->bi[i]->raw[r];
error.cpp:      sub = subs[raw->index]; // The sub object includes the map between the center and the raw positions
error.cpp:      for(pos0=0;pos0<center->length;pos0++) {
error.cpp:        pos1 = sub->map[pos0];
error.cpp:        nti0 = (int) (center->seq[pos0] - 1);
error.cpp:        nti1 = (int) (raw->seq[pos1] - 1);
error.cpp:        qual = raw->qual[pos1]; // qual=unsigned int
error.cpp:          transMat(t_ij, qual) += raw->reads;
error.cpp:          transMat(t_ij, 0) += raw->reads; 
error.cpp:      } // for(pos0=0;pos0<center->length;pos0++)
error.cpp:    } // for(r=0;b->bi[i]->nraw)
error.cpp:  } // for(i=0;i<b->nclust;i++)
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    for(r=0;r<b->bi[i]->nraw;r++) {
error.cpp:      raw = b->bi[i]->raw[r];
error.cpp:      sub = subs[raw->index];
error.cpp:        for(s=0;s<sub->nsubs;s++) {
error.cpp:          subs_by_pos(sub->pos[s]) += raw->reads;
error.cpp:        for(pos=0;pos<b->bi[i]->center->length;pos++) {
error.cpp:          pos1 = sub->map[pos];
error.cpp:          nts_by_pos(pos) += raw->reads;
error.cpp:            qind = raw->qual[pos1];  // qind = unsigned int
error.cpp:          nti0 = (int) b->bi[i]->center->seq[pos] - 1;
error.cpp:            if(j%5 == 0) { continue; } // the same-nt transitions
error.cpp:            exp_by_pos(pos) += raw->reads*errMat(j, qind);
error.cpp:  Rcpp::NumericMatrix Rquals(maxlen, b->nclust);
error.cpp:    for(i=0;i<b->nclust;i++) {
error.cpp:      seqlen = b->bi[i]->center->length;
error.cpp:      for(r=0;r<b->bi[i]->nraw;r++) {
error.cpp:        raw = b->bi[i]->raw[r];
error.cpp:        raw_reads = raw->reads;
error.cpp:        sub = subs[raw->index];
error.cpp:            pos1 = sub->map[pos0];
error.cpp:            Rquals(pos0,i) += (raw->qual[pos1] * raw_reads);  // Output qual construction
error.cpp:  for(i=0;i<b->nclust;i++) {
error.cpp:    if(sub) { tot_subs += sub->nsubs; }
error.cpp:  for(i=0,j=0;i<b->nclust;i++) {
error.cpp:      for(s=0;s<sub->nsubs;s++) {
error.cpp:        bs_pos[j] = sub->pos[s]+1; // R 1 indexing
error.cpp:        buf[0] = sub->nt0[s];
error.cpp:        buf[0] = sub->nt1[s];
error.cpp:          bs_qual[j] = sub->q1[s];  // NumericVector, making birth sub quals from sub object
evaluate.cpp://------------------------------------------------------------------
evaluate.cpp:// Exposes Needleman-Wunsch alignment to R.
evaluate.cpp:// @param band The band size (-1 turns off banding).
evaluate.cpp:  // Make integer-ized c-style sequence strings
evaluate.cpp:  // Make  c-style 2d score array
evaluate.cpp:  // Generate R-style return vector
evaluate.cpp://------------------------------------------------------------------
evaluate.cpp:  start = -1;
evaluate.cpp:    s1gap = s1gap && (s1[start] == '-');
evaluate.cpp:    s2gap = s2gap && (s2[start] == '-');
evaluate.cpp:    end--;
evaluate.cpp:    s1gap = s1gap && (s1[end] == '-');
evaluate.cpp:    s2gap = s2gap && (s2[end] == '-');
evaluate.cpp:    if(s1[i]=='-' || s2[i]=='-') {
evaluate.cpp://------------------------------------------------------------------
evaluate.cpp:    } else if(s2[i] == '-') {
evaluate.cpp:    } else if(s1[i] == '-') {
evaluate.cpp:      if(s1[i] != '-') { break; }
evaluate.cpp:      oseq[i] = '-';
evaluate.cpp:    for(i=s1.size()-1;i>=0;i--) {
evaluate.cpp:      if(s2[i] != '-') { break; }
evaluate.cpp:      oseq[i] = '-';
evaluate.cpp:    if(oseq[i] != '-') {
evaluate.cpp://------------------------------------------------------------------
evaluate.cpp:    klen1 = len1 - kmer_size + 1;
evaluate.cpp:    klen2 = len2 - kmer_size + 1;
filter.cpp:    for(j=0;j<=(len-word_size);j++) {
filter.cpp:      ee += pow(10.0, -inp(i,j)/10.0);
kmers.cpp: * Current Kmer implementation requires kmer size of 3-7 only.
kmers.cpp:  dot = ((double) dotsum)/((len1 < len2 ? len1 : len2) - k + 1.);
kmers.cpp:  return (1. - dot);
kmers.cpp:  dot = ((double) dotsum)/((len1 < len2 ? len1 : len2) - k + 1.);
kmers.cpp:  return (1. - dot);
kmers.cpp:  if(overflow) { return(-1.); }
kmers.cpp:  dot = ((double) dotsum)/((len1 < len2 ? len1 : len2) - k + 1.);
kmers.cpp:  return (1. - dot);
kmers.cpp:// If different lengths, returns -1 (invalid)
kmers.cpp:  if(len1 != len2 || kord1 == NULL || kord2 == NULL) { return(-1.0); } // Exit if different lengths
kmers.cpp:  size_t klen = len1 - k + 1;
kmers.cpp:  dot = ((double) dotsum)/((len1 < len2 ? len1 : len2) - k + 1.);
kmers.cpp:  return (1. - dot);
kmers.cpp:// If different lengths, returns -1 (invalid)
kmers.cpp:  if(kord1 == NULL || kord2 == NULL) { return(-1.0); }
kmers.cpp:  size_t klen = (len1 < len2 ? len1 : len2) - k + 1;
kmers.cpp:  size_t n_vec = klen - (klen % STEP); // Vectorize over this many
kmers.cpp:    vsum = _mm_sub_epi16(vsum, keq); // Using 0xFFFF = -1
kmers.cpp:  dot = ((double) dotsum)/((len1 < len2 ? len1 : len2) - k + 1.);
kmers.cpp:  return (1. - dot);
kmers.cpp:  if(k >= len || k < 3 || k > 8) { Rcpp::stop("Invalid kmer-size."); }
kmers.cpp:  size_t klen = len - k + 1; // The number of kmers in this sequence
kmers.cpp:      nti = ((int) seq[j]) - 1; // Change 1s, 2s, 3s, 4s, to 0/1/2/3
kmers.cpp:    // Make sure kmer index is valid. This doesn't solve the N's/-'s
kmers.cpp:    // to also reflect the reduction from the N's/-'s
kmers.cpp:  if(k >= len || k < 3 || k > 8) { Rcpp::stop("Invalid kmer-size."); }
kmers.cpp:  size_t klen = len - k + 1; // The number of kmers in this sequence
kmers.cpp:      nti = ((int) seq[j]) - 1; // Change 1s, 2s, 3s, 4s, to 0/1/2/3
kmers.cpp:    // Make sure kmer index is valid. This doesn't solve the N's/-'s
kmers.cpp:    // to also reflect the reduction from the N's/-'s
kmers.cpp:  if(k >= len || k < 1 || k > 8) { Rcpp::stop("Invalid kmer-size."); }
kmers.cpp:  size_t klen = len - k + 1; // The number of kmers in this sequence
kmers.cpp:      nti = ((int) seq[j]) - 1; // Change 1s, 2s, 3s, 4s, to 0/1/2/3
kmers.cpp:    // Make sure kmer index is valid. This doesn't solve the N's/-'s
kmers.cpp:    // to also reflect the reduction from the N's/-'s
misc.cpp:    case '-':
misc.cpp:      *oseq = '-';
misc.cpp:    case '-':
misc.cpp:      *oseq = '-';
nwalign_endsfree.cpp:  double kodist = -1.0; // Needs to be different than kdist for fall-back when use_kmers=FALSE
nwalign_endsfree.cpp:    if(SSE==2) { // 8-bit explicit SSE
nwalign_endsfree.cpp:      kdist = kmer_dist_SSEi_8(raw1->kmer8, raw1->length, raw2->kmer8, raw2->length, KMER_SIZE);
nwalign_endsfree.cpp:        kdist = kmer_dist_SSEi(raw1->kmer, raw1->length, raw2->kmer, raw2->length, KMER_SIZE);
nwalign_endsfree.cpp:    } else if(SSE==1) { // 16-bit explicit SSE
nwalign_endsfree.cpp:      kdist = kmer_dist_SSEi(raw1->kmer, raw1->length, raw2->kmer, raw2->length, KMER_SIZE);
nwalign_endsfree.cpp:      kdist = kmer_dist(raw1->kmer, raw1->length, raw2->kmer, raw2->length, KMER_SIZE);
nwalign_endsfree.cpp:      kodist = kord_dist_SSEi(raw1->kord, raw1->length, raw2->kord, raw2->length, KMER_SIZE);
nwalign_endsfree.cpp:    al = nwalign_gapless(raw1->seq, raw1->length, raw2->seq, raw2->length);
nwalign_endsfree.cpp:    al = nwalign_vectorized2(raw1->seq, raw1->length, raw2->seq, raw2->length, (int16_t) match, (int16_t) mismatch, (int16_t) gap_p, 0, band);
nwalign_endsfree.cpp:    al = nwalign_endsfree_homo(raw1->seq, raw1->length, raw2->seq, raw2->length, score, gap_p, homo_gap_p, band); // USES OLD SCORE_MATRIX FORMAT
nwalign_endsfree.cpp:    al = nwalign_endsfree(raw1->seq, raw1->length, raw2->seq, raw2->length, score, gap_p, band); // USES OLD SCORE_MATRIX FORMAT
nwalign_endsfree.cpp:    d[i*ncol] = 0; // ends-free gap
nwalign_endsfree.cpp:    d[j] = 0; // ends-free gap
nwalign_endsfree.cpp:  // Calculate left/right-bands in case of different lengths
nwalign_endsfree.cpp:    rband = band+len2-len1;
nwalign_endsfree.cpp:    lband = band+len1-len2;
nwalign_endsfree.cpp:      if(i-lband-1 >= 0) { d[i*ncol + i-lband-1] = -9999; }
nwalign_endsfree.cpp:      if(i+rband+1 <= len2) { d[i*ncol + i+rband+1] = -9999; }
nwalign_endsfree.cpp:      l = i-lband; if(l < 1) { l = 1; }
nwalign_endsfree.cpp:        left = d[i*ncol + j-1]; // Ends-free gap.
nwalign_endsfree.cpp:        left = d[i*ncol + j-1] + gap_p;
nwalign_endsfree.cpp:        up = d[(i-1)*ncol + j]; // Ends-free gap.
nwalign_endsfree.cpp:        up = d[(i-1)*ncol + j] + gap_p;
nwalign_endsfree.cpp:      diag = d[(i-1)*ncol + j-1] + score[s1[i-1]-1][s2[j-1]-1];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = '-';
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = '-';
nwalign_endsfree.cpp:      Rcpp::stop("N-W Align out of range.");
nwalign_endsfree.cpp:    al[0][i] = al0[len_al-i-1];
nwalign_endsfree.cpp:    al[1][i] = al1[len_al-i-1];
nwalign_endsfree.cpp:/* 08-17-15: MJR homopolymer free gapping version of ends-free alignment */
nwalign_endsfree.cpp:    if (j==len1-1 || s1[j]!=s1[j+1]) {
nwalign_endsfree.cpp:        if (j-i>=2) {//min homopolymer length = 3
nwalign_endsfree.cpp:    if (j==len2-1 || s2[j]!=s2[j+1]) {
nwalign_endsfree.cpp:        if (j-i>=2) { //min homopolymer length = 3
nwalign_endsfree.cpp:    d[i*ncol] = 0; // ends-free gap
nwalign_endsfree.cpp:    d[j] = 0; // ends-free gap
nwalign_endsfree.cpp:  // Calculate left/right-bands in case of different lengths
nwalign_endsfree.cpp:    rband = band+len2-len1;
nwalign_endsfree.cpp:    lband = band+len1-len2;
nwalign_endsfree.cpp:      if(i-lband-1 >= 0) { d[i*ncol + i-lband-1] = -9999; }
nwalign_endsfree.cpp:      if(i+rband+1 <= len2) { d[i*ncol + i+rband+1] = -9999; }
nwalign_endsfree.cpp:      l = i-lband; if(l < 1) { l = 1; }
nwalign_endsfree.cpp:        left = d[i*ncol + j-1]; // Ends-free gap.
nwalign_endsfree.cpp:      } else if (homo2[j-1]) {
nwalign_endsfree.cpp:        left = d[i*ncol + j-1] + homo_gap_p; //Homopolymer gap
nwalign_endsfree.cpp:        left = d[i*ncol + j-1] + gap_p;
nwalign_endsfree.cpp:        up = d[(i-1)*ncol + j]; // Ends-free gap.
nwalign_endsfree.cpp:      } else if (homo1[i-1]) {
nwalign_endsfree.cpp:          up = d[(i-1)*ncol + j] + homo_gap_p; //Homopolymer gap
nwalign_endsfree.cpp:        up = d[(i-1)*ncol + j] + gap_p;
nwalign_endsfree.cpp:      diag = d[(i-1)*ncol + j-1] + score[s1[i-1]-1][s2[j-1]-1];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = '-';
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = '-';
nwalign_endsfree.cpp:      Rcpp::stop("N-W Align out of range.");
nwalign_endsfree.cpp:    al[0][i] = al0[len_al-i-1];
nwalign_endsfree.cpp:    al[1][i] = al1[len_al-i-1];
nwalign_endsfree.cpp:    d[i*ncol] = d[(i-1)*ncol] + gap_p;
nwalign_endsfree.cpp:    d[j] = d[j-1] + gap_p;
nwalign_endsfree.cpp:  // Calculate left/right-bands in case of different lengths
nwalign_endsfree.cpp:    rband = band+len2-len1;
nwalign_endsfree.cpp:    lband = band+len1-len2;
nwalign_endsfree.cpp:      if(i-lband-1 >= 0) { d[i*ncol + i-lband-1] = -9999; }
nwalign_endsfree.cpp:      if(i+rband+1 <= len2) { d[i*ncol + i+rband+1] = -9999; }
nwalign_endsfree.cpp:      l = i-lband; if(l < 1) { l = 1; }
nwalign_endsfree.cpp:      left = d[i*ncol + j-1] + gap_p;
nwalign_endsfree.cpp:      up = d[(i-1)*ncol + j] + gap_p;
nwalign_endsfree.cpp:      diag = d[(i-1)*ncol + j-1] + score[s1[i-1]-1][s2[j-1]-1];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = '-';
nwalign_endsfree.cpp:      al1[len_al] = s2[--j];
nwalign_endsfree.cpp:      al0[len_al] = s1[--i];
nwalign_endsfree.cpp:      al1[len_al] = '-';
nwalign_endsfree.cpp:      Rcpp::stop("N-W Align out of range.");
nwalign_endsfree.cpp:    al[0][i] = al0[len_al-i-1];
nwalign_endsfree.cpp:    al[1][i] = al1[len_al-i-1];
nwalign_endsfree.cpp:    al[0][i] = i < len1 ? s1[i] : '-';
nwalign_endsfree.cpp:    al[1][i] = i < len2 ? s2[i] : '-';
nwalign_endsfree.cpp:  if(!al) { // Null alignment (outside kmer thresh) -> Null sub
nwalign_endsfree.cpp:    is_nt0 = ((al0[i] == 1) || (al0[i] == 2) || (al0[i] == 3) || (al0[i] == 4) || (al0[i] == 5)); // A/C/G/T/N (non-gap) in seq0
nwalign_endsfree.cpp:    is_nt1 = ((al1[i] == 1) || (al1[i] == 2) || (al1[i] == 3) || (al1[i] == 4) || (al1[i] == 5)); // A/C/G/T/N (non-gap) in seq1
nwalign_endsfree.cpp:  sub->len0 = len0;
nwalign_endsfree.cpp:  sub->map = (uint16_t *) malloc(len0 * sizeof(uint16_t)); //E
nwalign_endsfree.cpp:  sub->pos = (uint16_t *) malloc(nsubs * sizeof(uint16_t)); //E
nwalign_endsfree.cpp:  sub->nt0 = (char *) malloc(nsubs); //E
nwalign_endsfree.cpp:  sub->nt1 = (char *) malloc(nsubs); //E
nwalign_endsfree.cpp:  if (sub->map == NULL || sub->pos == NULL || sub->nt0 == NULL || sub->nt1 == NULL) {
nwalign_endsfree.cpp:  sub->nsubs=0;
nwalign_endsfree.cpp:  i0 = -1; i1 = -1;
nwalign_endsfree.cpp:    is_nt0 = ((al0[i] == 1) || (al0[i] == 2) || (al0[i] == 3) || (al0[i] == 4) || (al0[i] == 5)); // A/C/G/T/N (non-gap) in seq0
nwalign_endsfree.cpp:    is_nt1 = ((al1[i] == 1) || (al1[i] == 2) || (al1[i] == 3) || (al1[i] == 4) || (al1[i] == 5)); // A/C/G/T/N (non-gap) in seq1
nwalign_endsfree.cpp:        sub->map[i0] = i1; // Assigning a signed into to a uint16_t...
nwalign_endsfree.cpp:        sub->map[i0] = GAP_GLYPH; // Indicates gap
nwalign_endsfree.cpp:        sub->pos[sub->nsubs] = i0;
nwalign_endsfree.cpp:        sub->nt0[sub->nsubs] = al0[i];
nwalign_endsfree.cpp:        sub->nt1[sub->nsubs] = al1[i];
nwalign_endsfree.cpp:        sub->nsubs++;
nwalign_endsfree.cpp:    sub->q0 = NULL;
nwalign_endsfree.cpp:    sub->q1 = NULL;
nwalign_endsfree.cpp:    if(raw0->qual && raw1->qual) {
nwalign_endsfree.cpp:      sub->q0 = (uint8_t *) malloc(sub->nsubs * sizeof(uint8_t)); //E
nwalign_endsfree.cpp:      sub->q1 = (uint8_t *) malloc(sub->nsubs * sizeof(uint8_t)); //E
nwalign_endsfree.cpp:      if (sub->q0 == NULL || sub->q1 == NULL) { Rcpp::stop("Memory allocation failed."); }
nwalign_endsfree.cpp:      for(s=0;s<sub->nsubs;s++) {
nwalign_endsfree.cpp:        sub->q0[s] = raw0->qual[sub->pos[s]]; // allocated uint8_t
nwalign_endsfree.cpp:        sub->q1[s] = raw1->qual[sub->map[sub->pos[s]]]; // allocated uint8_t
nwalign_endsfree.cpp:  nsubs = sub->nsubs;
nwalign_endsfree.cpp:  len0 = sub->len0;
nwalign_endsfree.cpp:  rsub->map = (uint16_t *) malloc(len0 * sizeof(uint16_t)); //E
nwalign_endsfree.cpp:  rsub->pos = (uint16_t *) malloc(nsubs * sizeof(uint16_t)); //E
nwalign_endsfree.cpp:  rsub->nt0 = (char *) malloc(nsubs); //E
nwalign_endsfree.cpp:  rsub->nt1 = (char *) malloc(nsubs); //E
nwalign_endsfree.cpp:  if (rsub->map == NULL || rsub->pos == NULL || rsub->nt0 == NULL || rsub->nt1 == NULL) {
nwalign_endsfree.cpp:  rsub->nsubs = sub->nsubs;
nwalign_endsfree.cpp:  rsub->len0 = sub->len0;
nwalign_endsfree.cpp:  memcpy(rsub->map, sub->map, len0 * sizeof(uint16_t));
nwalign_endsfree.cpp:  memcpy(rsub->pos, sub->pos, nsubs * sizeof(uint16_t));
nwalign_endsfree.cpp:  memcpy(rsub->nt0, sub->nt0, nsubs);
nwalign_endsfree.cpp:  memcpy(rsub->nt1, sub->nt1, nsubs);
nwalign_endsfree.cpp:  if(sub->q0 && sub->q1) {
nwalign_endsfree.cpp:    rsub->q0 = (uint8_t *) malloc(nsubs * sizeof(uint8_t)); //E
nwalign_endsfree.cpp:    rsub->q1 = (uint8_t *) malloc(nsubs * sizeof(uint8_t)); //E
nwalign_endsfree.cpp:    if (rsub->q0 == NULL || rsub->q1 == NULL) { Rcpp::stop("Memory allocation failed."); }
nwalign_endsfree.cpp:    memcpy(rsub->q0, sub->q0, nsubs * sizeof(uint8_t)); // allocated double
nwalign_endsfree.cpp:    memcpy(rsub->q1, sub->q1, nsubs * sizeof(uint8_t)); // allocated double
nwalign_endsfree.cpp:    rsub->q0 = NULL;
nwalign_endsfree.cpp:    rsub->q1 = NULL;
nwalign_endsfree.cpp:    free(sub->nt1);
nwalign_endsfree.cpp:    free(sub->nt0);
nwalign_endsfree.cpp:    free(sub->pos);
nwalign_endsfree.cpp:    free(sub->map);
nwalign_endsfree.cpp:    if(sub->q0) { free(sub->q0); }
nwalign_endsfree.cpp:    if(sub->q1) { free(sub->q1); }
nwalign_vectorized.cpp:  end_col = start_col + (len2-len1)/2;
nwalign_vectorized.cpp:  ncol = 2 + start_col + ((len2-len1+band)<len2 ? (len2-len1+band) : len2)/2;
nwalign_vectorized.cpp:  int16_t fill_val = INT16_MIN - MIN(MIN(mismatch, gap_p), MIN(match, 0));
nwalign_vectorized.cpp:    d[row*ncol+ncol-2] = fill_val;
nwalign_vectorized.cpp:    d[row*ncol+ncol-1] = fill_val;
nwalign_vectorized.cpp:  col=start_col-1;
nwalign_vectorized.cpp:  d_free = end_gap_p; // end-gap score
nwalign_vectorized.cpp:      col--;
nwalign_vectorized.cpp:  d_free = end_gap_p; // end-gap score
nwalign_vectorized.cpp:  while(row < (1+(band+len2-len1 < len2 ? band+len2-len1 : len2))) {
nwalign_vectorized.cpp:  // Fill out DP matrix (Row 0/1 taken care of by ends-free)
nwalign_vectorized.cpp:  col_min = start_col; // Do not fill out the ends-free cells
nwalign_vectorized.cpp:    for(col=col_min,i=i_max,j=j_min;col<(1+col_max);col++,i--,j++) {
nwalign_vectorized.cpp:      diag_buf[col] = d[(row-2)*ncol + col] + (s1[i] == s2[j] ? match : mismatch);
nwalign_vectorized.cpp:    ptr_left = &d[(row-1)*ncol + col_min-even];
nwalign_vectorized.cpp:    ptr_up = &d[(row-1)*ncol + col_min+1-even];
nwalign_vectorized.cpp:      dploop_vec_swap(ptr_left, ptr_diag, ptr_up, &d[row*ncol + col_min], &p[row*ncol + col_min], gap_p, col_max-col_min+1);
nwalign_vectorized.cpp:      dploop_vec(ptr_left, ptr_diag, ptr_up, &d[row*ncol + col_min], &p[row*ncol + col_min], gap_p, col_max-col_min+1);
nwalign_vectorized.cpp:      col_min--;
nwalign_vectorized.cpp:      j_min--;
nwalign_vectorized.cpp:    if(row == (band+len2-len1 < len2 ? band+len2-len1 : len2)) {
nwalign_vectorized.cpp:    // Recalculate ends-free cells for lower boundary
nwalign_vectorized.cpp:        if(d_free > d[row*ncol + col_min]) { // ends-free gap is better
nwalign_vectorized.cpp:        } else if(swap && d_free == d[row*ncol + col_min] && p[row*ncol + col_min] != 2) { // left-is-up, and takes precedence other moves
nwalign_vectorized.cpp:      if(i_max == len1-1) { recalc_left = true; }
nwalign_vectorized.cpp:        d_free = ptr_up[col_max-col_min] + end_gap_p; // last cell of up array
nwalign_vectorized.cpp:        if(d_free > d[row*ncol + col_max]) { // ends-free gap is better
nwalign_vectorized.cpp:        } else if(swap && d_free == d[row*ncol + col_max] && p[row*ncol + col_max] == 1) { // up-is-left, and takes precedence over diagonal
nwalign_vectorized.cpp:      if((row+1)/2 + col_max - start_col == len2) { recalc_right = true; }
nwalign_vectorized.cpp:      // j_max (1-index) = (row+1)/2 + col_max - start_col
nwalign_vectorized.cpp:      if(even) { col_min--; }
nwalign_vectorized.cpp:    } else if(i_max < len1-1) { // banded area
nwalign_vectorized.cpp:        if(even) { col_min--; i_max++; }
nwalign_vectorized.cpp:    if(row<(band+len2-len1 < len2 ? band+len2-len1 : len2)) {
nwalign_vectorized.cpp:    } else if((row+1)/2 + col_max - start_col < len2) { // "j_max" (1-index) < len2
nwalign_vectorized.cpp:      if((band+len2-len1) % 2 == 0) { // even band (including the extra band from length difference)
nwalign_vectorized.cpp:        if(even) { col_max--; }
nwalign_vectorized.cpp:      if(even) { col_max--; }
nwalign_vectorized.cpp:    even = 1 - even;
nwalign_vectorized.cpp://    Rprintf("Score: %d\n", d[(len1+len2)*ncol + (2*start_col+len2-len1)/2]);
nwalign_vectorized.cpp:    switch ( p[(i+j)*ncol + (2*start_col+j-i)/2] ) {
nwalign_vectorized.cpp:        al0[len_al] = s1[--i];
nwalign_vectorized.cpp:        al1[len_al] = s2[--j];
nwalign_vectorized.cpp:        al0[len_al] = '-';
nwalign_vectorized.cpp:        al1[len_al] = s2[--j];
nwalign_vectorized.cpp:        al0[len_al] = s1[--i];
nwalign_vectorized.cpp:        al1[len_al] = '-';
nwalign_vectorized.cpp:        Rprintf("len1/2=(%i, %i), nrow,ncol=(%i,%i), ij=(%i,%i), rc=(%i,%i), d[][]=%i, p[][]=%i\n", len1, len2, nrow, ncol, i,j,i+j,(2*start_col+j-i)/2, d[(i+j)*ncol + (2*start_col+j-i)/2], p[(i+j)*ncol + (2*start_col+j-i)/2]);
nwalign_vectorized.cpp:        Rcpp::stop("N-W Align out of range.");
nwalign_vectorized.cpp:    al[0][i] = al0[len_al-i-1];
nwalign_vectorized.cpp:    al[1][i] = al1[len_al-i-1];
pval.cpp:  n_repeats(0) = reads-1; // -1 since strict > being calculated, and want to include the observed count
pval.cpp:    norm = (1.0 - exp(-E_reads));
pval.cpp:      norm = E_reads - 0.5*E_reads*E_reads; 
pval.cpp:  lambda = raw->comp.lambda;
pval.cpp:  hamming = raw->comp.hamming;
pval.cpp:  if(raw->reads == 1 && !raw->prior) {   // Singleton. No abundance pval.
pval.cpp:    E_reads = lambda * bi->reads;
pval.cpp:    pval = calc_pA(raw->reads, E_reads, raw->prior);
pval.cpp:  // Index is 0: A->A, 1: A->C, ..., 4: C->A, ...
pval.cpp:  len1 = raw->length;
pval.cpp:    nti1 = ((int) raw->seq[pos1]) - 1;
pval.cpp:      Rcpp::stop("Non-ACGT sequences in compute_lambda.");
pval.cpp:      qind[pos1] = raw->qual[pos1]; // unsigned int
pval.cpp:  for(s=0;s<sub->nsubs;s++) {
pval.cpp:    pos0 = sub->pos[s];
pval.cpp:    if(pos0 < 0 || pos0 >= sub->len0) { Rcpp::stop("CL: Bad pos0: %i (len0=%i).", pos0, sub->len0); }
pval.cpp:    pos1 = sub->map[sub->pos[s]];
pval.cpp:    nti0 = ((int) sub->nt0[s]) - 1;
pval.cpp:    nti1 = ((int) sub->nt1[s]) - 1;
pval.cpp:  // Index is 0: A->A, 1: A->C, ..., 4: C->A, ...
pval.cpp:  len1 = raw->length;
pval.cpp:    nti1 = ((int) raw->seq[pos1]) - 1;
pval.cpp:      Rcpp::stop("Non-ACGT sequences in compute_lambda.");
pval.cpp:      qind[pos1] = raw->qual[pos1]; // qind = unsigned int
pval.cpp:    if( qind[pos1] > (ncol-1) ) {
pval.cpp:  for(s=0;s<sub->nsubs;s++) {
pval.cpp:    pos0 = sub->pos[s];
pval.cpp:    if(pos0 < 0 || pos0 >= sub->len0) { Rcpp::stop("CL: Bad pos0: %i (len0=%i).", pos0, sub->len0); }
pval.cpp:    pos1 = sub->map[sub->pos[s]];
pval.cpp:    nti0 = ((int) sub->nt0[s]) - 1;
pval.cpp:    nti1 = ((int) sub->nt1[s]) - 1;
pval.cpp: *  https://github.com/wch/r-source/blob/af7f52f70101960861e5d995d3a4bec010bc89e6/src/nmath/ppois.c
pval.cpp: *  https://github.com/wch/r-source/blob/af7f52f70101960861e5d995d3a4bec010bc89e6/src/nmath/pgamma.c
pval.cpp: *  Copyright (C) 2005-6 Morten Welinder <terra@gnome.org>
pval.cpp: *  Copyright (C) 2005-10 The R Foundation
pval.cpp: *  Copyright (C) 2006-2015 The R Core Team
pval.cpp: *  https://www.R-project.org/Licenses/
pval.cpp:  x = floor(x + 1e-7); // Why?
pval.cpp:  } else if (x <= alph - 1 && x < 0.8 * (alph + 50)) {
pval.cpp:        : 1 - d * sum;
pval.cpp:  } else if (alph - 1 < x && alph < 0.8 * (x + 50)) {
pval.cpp:      if (x * DBL_EPSILON > 1 - alph)
pval.cpp:        double f = pd_lower_cf (alph, x - (alph - 1)) * x / alph;
pval.cpp:        // = [alph/(x - alph+1) + o(alph/(x-alph+1))] * x/alph = 1 + o(1) 
pval.cpp:      sum = pd_lower_series (x, alph - 1);// = (alph-1)/x + o((alph-1)/x) 
pval.cpp:        : 1 - d * sum;
pval.cpp:    res = ppois_asymp (alph - 1, x, !lower_tail, log_p);
pval.cpp:    // with(.Machine, double.xmin / double.eps) #|-> 1.002084e-292
pval.cpp:/// dpois_wrap (x__1, lambda) := dpois(x__1 - 1, lambda);  where
pval.cpp: // dpois(k, L) := exp(-L) L^k / gamma(k+1)  {the usual Poisson probabilities}
pval.cpp:      return dpois_raw (x_plus_1 - 1, lambda, give_log);
pval.cpp:    if (lambda > fabs(x_plus_1 - 1) * M_cutoff)
pval.cpp:      return R_D_exp(-lambda - lgammafn(x_plus_1));
taxonomy.cpp:// Returns -1 if non-ACGT base encountered
taxonomy.cpp:      kmer = -1;
taxonomy.cpp:  for(i=0; i<len-k; i++) {
taxonomy.cpp:  for(i=0,j=0;i<len-k;i++) {
taxonomy.cpp:  int kmer, g, max_g = -1;
taxonomy.cpp:    logp = logp - (arraylen * log(genus_num_plus1[g]));
taxonomy.cpp://------------------------------------------------------------------
taxonomy.cpp:  // Rprintf("Validated and 0-index ref_to_genus map.\n");
taxonomy.cpp:    ref_to_genus[i] = ref_to_genus[i]-1; // -> 0-index
taxonomy.cpp:    // Calculate kmer-vector of this reference sequences
taxonomy.cpp:    // Assign the kmer-counts to the appropriate "genus" and kmer-prior
taxonomy.cpp:    if((seqlen-k) > max_arraylen) { max_arraylen = seqlen-k; }
taxonomy.cpp:    if(try_rc) { // see if rev-comp is a better match to refs
taxonomy.cpp:      if(logp_rc > logp) { // rev-comp is better, replace with it
taxonomy.cpp:    rval(j) = max_g+1; // 1-index for return
taxonomy.cpp:      rboot_tax(j,boot) = boot_g+1; // 1-index for return
taxonomy.cpp:      if(try_rc) { // see if rev-comp is a better match to refs
taxonomy.cpp:        if(logp_rc > logp) { // rev-comp is better, replace with it
taxonomy.cpp:      C_rval[j] = max_g+1; // 1-index for return
taxonomy.cpp:        C_rboot_tax[j*100+boot] = boot_g+1; // 1-index for return
taxonomy.cpp://------------------------------------------------------------------
taxonomy.cpp:  // Rprintf("Validated and 0-index ref_to_genus map.\n");
taxonomy.cpp:    ref_to_genus[i] = ref_to_genus[i]-1; // -> 0-index
taxonomy.cpp:    // Calculate kmer-vector of this reference sequences
taxonomy.cpp:    // Assign the kmer-counts to the appropriate "genus" and kmer-prior
taxonomy.cpp:    if((seqlen-k) > max_arraylen) { max_arraylen = seqlen-k; }
taxonomy.cpp:  // Allocate return values, plus thread-safe C versions of source data
taxonomy.cpp:  // Copy from C-versions back to R objects
